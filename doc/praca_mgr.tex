\documentclass[11pt,a4paper]{article}
\usepackage[a4paper, left=3cm, right=2.5cm, top=2.5cm, bottom=2.5cm, headsep=1.5cm]{geometry}
\usepackage{graphicx}
\usepackage[T1]{fontenc}
\usepackage[polish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{float}
\usepackage{grffile}
\usepackage{color}
\usepackage{xcolor}
\usepackage{listings}
\usepackage[figuresleft]{rotating}
\usepackage{multirow}
\usepackage{subfig}
\selectlanguage{polish}
\usepackage{makecell}
\usepackage{bytefield}
\usepackage{listings}
\usepackage{hyperref}
\usepackage[super]{natbib}
\usepackage{tikz}
\usepackage{ifthen}
\urlstyle{same}
\def\code#1{\texttt{#1}}
\setlength{\parindent}{5mm}
\captionsetup[table]{
name = Tabela
}
\usepackage{titlesec}
\usepackage{caption}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}
\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}
\begin{document}
	\date{}
\begin{center}
	\centering

\includegraphics[width=4cm]{./rysunki/logo.jpg}
\\
\vspace{1.5cm}
 
\textbf{\Large POLITECHNIKA ŚLĄSKA}
\\
\vspace{0.5cm}
 
\textbf{\Large WYDZIAŁ AUTOMATYKI, ELEKTRONIKI}
\\
\vspace{0.1cm}
\textbf{\Large I INFORMATYKI}
\\
\vspace{0.5cm}


\vspace{3cm}
 
\textbf{\LARGE  Praca dyplomowa magisterska}
\\
\vspace{2cm}

\Large Implementacja SoC na podstawie mikroprocesora RISC-V Ibex
\vspace{3cm}

\begin{flushleft}

\Large Autor: inż. Dawid Zimończyk
\\
\Large Kierujący pracą: dr hab. inż. Robert Czerwiński, prof. Pol. Śl.
\\

\end{flushleft}
 \vspace{2.5cm}
\Large Gliwice, wrzesień 2020


\end{center}
\thispagestyle{empty}



\thispagestyle{empty}
\setcounter{page}{2}

\newpage

\begin{center}
\textbf {\Large Od autora}
\newpage
\end{center}
\large\tableofcontents 

\newpage
\listoffigures
%\newpage
%\listoftables


\newpage
\begin{flushleft}
\textbf {\Large Spis ważniejszych oznaczeń}

SoC - System on Chip
\\ISA - instruction set architecture
\\RISC - Reduced Instruction Set Computing
\\UVM - Universal Verification Methodology
\\I2C - Inter-Integrated Circuit
\\SPI - Serial Peripheral Interface
\\UART - universal asynchronous receiver-transmitter
\\RAM - random-access memory
\\PWM - Pulse-Width Modulation
\\GPIO - general-purpose input/output
\\FPGA - field-programmable gate array
\\ISS - instruction set simulator
\\SV - SystemVerilog
\\DV - design verification
\\ISP - In-System Programming
\\JTAG - Joint Test Action Group
\\PC - program counter
\\LSB - least significant bit
\\MSB - most significant bit
\\IP - intellectual property
\\TLM - Transaction Level Modeling
\\DUT - Device under test
\\TCL - Tool Command Language
%\\HDL - hardware description language
\\PLL - phase-locked loop
\\Pmod - Peripheral Module interface
\\ALU - Arithmetic Logic Unit 
\end{flushleft}
\vspace{0.5cm}


\newpage
\section{Wprowadzenie} 

	\subsection{Wstęp}
	\hspace{5mm}
Systemy na chipie znane również jako SoC, występują między innymi w naszych telefonach czy samochodach. Również są częścią systemów wbudowanych, te zaś są wykorzystywane w każdej dziedzinie życia, od zegarków elektronicznych po zaawansowane roboty medyczne. Ważne jest więc by układy te były niezawodne i działały w zamierzony sposób. W celu weryfikacji działania układów, są wykorzystywane symulatory języków opisu sprzętu takie jak Riviera-PRO.
\\
\\
SoC powinien składać się z mikroprocesora, mikrokontrolera lub rdzenia DSP. Każdy mikroprocesor posiada 'Model programowy procesora' (ang Instruction Set Architecture, ISA). ISA definiuje jak mikroprocesor powinien działać, jego listę rozkazów, typ danych, tryby adresowania, rejestry dostępne dla programisty, zasady obsługi przerwań i wyjątków. Przykładowe komercyjne ISA: ARM, MIPS, Power ISA. Jest również otwarty model programowy procesora, który jest oparty o zasady RISC, jest nim RISC-V. Otwarta standard ISA oznacza, że dostęp nie jest limitowany prawnie, finansowo lub tajemnicą handlową firmy.
\newline
\newline
Przykładem mikroprocesora wykorzystującego ISA RISC-V jest Ibex. Jest on tworzony przez lowRISC, wywodzącego się z Uniwersytety w Cambridge. Mikroprocesor ten jest 32bit, składa się z 2-stage pipileine i został zaimplementowany na bazie RV32IMC.


	\subsection{Cel i zakres pracy}
	\hspace{5mm}
	Celem pracy jest implementacja SoC na podstawie mikroprocesora Ibex RISC-V. Mikroprocesor należy przystosować do implantacji na płytce FPGA NEXYS4DDR oraz dodać odpowiednie peryferia. Następnie przeprowadzić weryfikację zaimplementowanego systemu na chipie poprzez przeprowadzenie symulacji korzystając z biblioteki UVM 1.2 i testów RISCV complience. Weryfikacji zostanie poddany cały SoC jak i poszczególne peryferia.\newline
	Zakres pracy obejmuje:
	\begin{itemize}
	  \item Implementacje mikroprocesora IBEX
	  \item Implementacje peryferii:
	  \begin{enumerate}
	  	\item RAM
	  	\item SPI
	  	\item I2C
	  	\item UART
	  	\item GPIO
	  	\item Timer
	  \end{enumerate}
	  \item Kompilacja toolchaina i przystosowanie go dla SoC
	  \item Przeprowadzenie weryfikacji
  	  \item Porównanie wyników dla poszczególnych architektur i pamięci
  	  \item Podsumowanie wyników pracy
	\end{itemize}

	\subsection{Zarys pracy}
	\hspace{5mm}
	Praca składa się z 6 rozdziałów. Pierwszy zawiera krótkie omówienie tematu pracy, jej celu i zarys. Drugi rozdział jest poświęcony teorii. Opisuje on zagadnienia związane z ISA RISC-V, SoC, mikroprocesorem Ibex, kompilatorem, weryfikacją, płytce FPGA Nexys4 DDR i programem wykorzystanym do syntezy oraz programem do symulacji. Trzeci rozdział skupia się na implementacji poszczególnych części systemu na chipie, przedstawione zostaną w nim fragmentu opisu sprzętu, schematy blokowe i FSM. Czwarty rozdział przedstawia weryfikacje, opisuje przebiegające fazy biblioteki UVM 1.2 oraz jej wyniki. Następnie pokazuje symulację przeprowadzaną z instrukcjami wygenerowanymi przez RISCV-DV, Wyniki tej symulacji zostaną porównane z ISS Ovpsim i Spike. W piątym rozdziale zostaną porównane wyniki symulacji oraz syntezy architektury Von Neumanna z architekturą Harvardzką, pamięć RAM jedno-portowa z pamięcią RAM dwu-portową. Ostatni rozdział to podsumowanie oraz propozycję dalszego rozwoju projektu.
\newpage
	
\section{Część teoretyczna}

	\subsection{RISC V}

		\subsubsection{Instruction set architecture ISA}
		\hspace{5mm}
		RISC-V to otwarta ISA bazująca na architekturze RISC. Oznacza to, że licensja jest typu Open-source, która pozwala na wprowadzanie dowonlych modyfikacji\cite{open_source}, również jest nie wymaga żadnych opłat za wykorzystywanie jej w komercyjnych celach. Dokumentacja składa się z trzech części\cite{isa_site}:
		\begin{enumerate}
			\item User-Level ISA Specification - specyfikacja ISA poziomu użytkownika
			\item Privileged ISA Specifiation - specyfikacja ISA przywilejów
			\item Debug Specification - specyfikacja debugowania 
		\end{enumerate}
		Podstawowe cechy architektury RISC to:
		\begin{itemize}
		\item Zredukowana lista rozkazów, jest ich kilkadziesiąt
		\item Przepustowość procesora zbliżona do jednej instrukcji na cylk
		\item Zredukowana tryby adresowania, kody rozkazów są prostsze
		\item Powiększenie liczby rejestrów
		\item Minimalizacja komunikacja między procesorem a pamięcią
		\item Instrukcje mogą operować na dowolnych rejestrach
		\item Instrukcje zajmują w pamięci taką samą liczbę bajtów
		\item Procesor posiada architekturę Harwardzką
		\item Procesor używa przetwarzania potokowego
		\end{itemize}
		Są cztery podstawowe zestawy instrukcji oraz piętnaście ich rozszerzeń. W tabeli \ref{Tab:ISA} przedstawiono ich podział.
				Instrukcje są 32-bit. Tabela \ref{Tab:instruction} przedstawia formaty tych instrukcji. Korzystają one z sześciu formatów:
		\begin{itemize}
			\item Register (R) - instrukcje realizują działania na dwóch rejestrach {\it rs1} i {\it rs2}, wynik jest zapisywany w rejestrze {\it rd}.
			\item Immediate (I) - instrukcje realizują działania rejestrze {\it rs1} i liczbie 12bitowej stałej ze znakiem, wynik jest zapisywany w rejestrze {\it rd}.
			\item Upper immediate (U) - format wykorzystywany dla dwóch instrukcji: {\it LUI}, {\it AUIPC}. Służy do przypisywania liczb 20bitowych do rejestru {\it rd}.
			\item Store (S) - instrukcje realizują zapis do pamięci, pobierany jest bazowy adres z rejestru {\it rs1} + offset pochodzący z {\it imm}, rejestr {\it rs2} przechowuje.
			\item Branch (SB) - instrukcje realizują skoki warunkowe.
			\item Jump (UJ) - instrukcje służące do skoków, dodają wartość {\it imm} do {\it PC}.
		\end{itemize}
		\begin{minipage}{\textwidth}
		\begin{center}
			\captionof{table}{ISA base and extensions\label{Tab:ISA}\cite{isa_book}}
						\scalebox{1}{\small
			\begin{tabular}{|c|c|}
				\hline
				Nazwa  & Opis\\
				\hline
				\multicolumn{2}{|c|}{Podstawowe} \\
				\hline
				RV32I & Base Integer Instruction Set, 32-bit\\
				\hline
				RV32E & Base Integer Instruction Set (embedded), 32-bit, 16 registers\\
				\hline
				RV64I & Base Integer Instruction Set, 64-bit \\
				\hline
				RV128I & Base Integer Instruction Set, 128-bit \\
				\hline
				\multicolumn{2}{|c|}{Rozszerzenia} \\
				\hline
				M & Standard Extension for Integer Multiplication and Division \\
				\hline
				A & Standard Extension for Atomic Instructions \\
				\hline
				F & Standard Extension for Single-Precision Floating-Point \\
				\hline
				D & Standard Extension for Double-Precision Floating-Point \\
				\hline
				G & Shorthand for the base and above extensions \\
				\hline
				Q & Standard Extension for Quad-Precision Floating-Point \\
				\hline
				L & Standard Extension for Decimal Floating-Point \\
				\hline
				C & Standard Extension for Compressed Instructions \\
				\hline
				B & Standard Extension for Bit Manipulation \\
				\hline
				J & Standard Extension for Dynamically Translated Languages \\
				\hline
				T & Standard Extension for Transactional Memory \\
				\hline
				P & Standard Extension for Packed-SIMD Instructions \\
				\hline
				V & Standard Extension for Vector Operations \\
				\hline
				N & Standard Extension for User-Level Interrupts \\
				\hline
				H & Standard Extension for Hypervisor \\
				\hline
				\end{tabular}}
		\end{center}
	\end{minipage}

		\subsubsection{Rejestry}
		\hspace{5mm}
		RISC-V posiada 32 rejestry (tryb embeded posiada tylko 16). Jeśli korzystamy z rozszerzenia zawierającego liczby zmiennoprzecinkowe, dodane zostają kolejne 32 rejestry. Pierwszy rejestr nazywany jest rejestrem zerowym. Zawsze przyjmuje wartość zera, a wszystkie dane zapisywane do niego są tracone. Służy on jako rejestr pomocniczy w wielu instrukcjach.
		\begin{center}
			\captionof{table}{Rejestry RISC-V\label{Tab:registers}\cite{isa_book}}
			\scalebox{0.8}{\small
			\begin{tabular}{|c|c|c|c|}
			\hline
			Nazwa rejestry & Nazwa symboliczna& Opis & Właściciel \\
			\hline
			x0 & Zero & zawsze zero & \\
			\hline
			x1 & ra & adres powrotu &  wywołujący \\
			\hline
			x2 & sp & wskaźnik stosu & wołany (callee<?>) \\
			\hline
			x3 & gp & wskaźnik globalny & \\
			\hline
			x4 & tp & wskaźnik wątku & \\
			\hline
			x5 & t0 & \makecell{zmienna tymczasowa\\/ alternatywny adres powrotu} & wywołujący \\
			\hline
			x6-7 & t1-2& zmienne tymczasowe & wywołujący \\
			\hline
			x8 & s0/fp& zapisany rejestr / wskaźnik ramki & wołany \\
			\hline
			x9 & s1 & zapisany rejestr & wołany \\
			\hline
			x10-11 & a0-1 & argument funkcji / wartość zwracana & wywołujący \\
			\hline 
			x12-17 & a-2-7 & argument funkcji & wołany\\
			\hline
			x18-27 & s2-11 & zapisane rejestry & wołany \\
			\hline
			x28-31 & t3-6 & zmienne tymczasowe & wywołujący \\
			\hline
			\multicolumn{4}{|c|}{32 rejestry dla zmiennoprzecinkowego rozszerzenia} \\
			\hline
			f0-7 & ft0-7 & \makecell{tymczasowe zmienne \\ zmiennoprzecinkowe} & wywołujący \\
			\hline
			f8-9 & fs0-1 & \makecell{zapisane rejestry \\ zmiennoprzecinkowe} & wołany \\
			\hline
			f10-11 & fa0-1 & \makecell{argumenty/wartość zwaracana \\ zmiennoprzecinkowe} & wywołujący \\
			\hline
			f12-17 & fa2-7 & \makecell{argumenty \\ zmiennoprzecinkowe} & wywołujący \\
			\hline
			f18-27 & fs2-11 & \makecell{zapisane rejestry\\ zmiennoprzecinkowe} & wywołujący \\
			\hline
			f28-31 & fs8-11 & \makecell {tymczasowe zmienne \\zmiennoprzecinkowe} & wywołujący \\
			\hline
			\end{tabular}}
		\end{center}
		\begin{sidewaystable}
					\captionof{table}{32-bit RISC-V formaty instrukcji\label{Tab:instruction}\cite{isa_book}}
		\scalebox{0.9}{\small
			\begin{tabular}{*{33}{|c}|}
				\hline
              \multirow {2}{*}{Format} & \multicolumn{32}{c|}{Bit} \\
				\cline{2-33}
               & 31 & 30 & 29 & 28 & 27 & 26 & 25 & 24 & 23 & 22 & 21 & 20 & 19 & 18 & 17 & 16 & 15 & 14 & 13 & 12 & 11 & 10 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\
               \hline
               R & \multicolumn{7}{c|}{funct7}&\multicolumn{5}{c|}{rs2}&\multicolumn{5}{c|}{rs1}&\multicolumn{3}{c|}{funct3}&\multicolumn{5}{c|}{rd}&\multicolumn{7}{c|}{opcode}\\
               \hline
               I & \multicolumn{12}{c|}{imm[11:0]}&\multicolumn{5}{c|}{rs1}&\multicolumn{3}{c|}{funct3}&\multicolumn{5}{c|}{rd}&\multicolumn{7}{c|}{opcode}\\
               \hline
               U & \multicolumn{20}{c|}{imm[31:12]}&\multicolumn{5}{c|}{rd}&\multicolumn{7}{c|}{opcode}\\
               \hline
               S & \multicolumn{7}{c|}{imm[11:5]}&\multicolumn{5}{c|}{rs2}&\multicolumn{5}{c|}{rs1}&\multicolumn{3}{c|}{funct3}&\multicolumn{5}{c|}{imm[4:0]}&\multicolumn{7}{c|}{opcode}\\
               \hline
               SB & [12] & \multicolumn{6}{c|}{imm[10:5]}&\multicolumn{5}{c|}{rs2}&\multicolumn{5}{c|}{rs1}&\multicolumn{3}{c|}{funct3}&\multicolumn{4}{c|}{imm[4:1]}&[11]&\multicolumn{7}{c|}{opcode}\\
               \hline
               UJ & [20] & \multicolumn{10}{c|}{imm[10:1]}&[11]&\multicolumn{8}{c|}{imm[19:12]}&\multicolumn{5}{c|}{rd}&\multicolumn{7}{c|}{opcode}\\
               \hline
			\end{tabular}
			}
		\end{sidewaystable}
		
		\newpage

		\subsubsection{Dostęp do pamięci}
		\hspace{5mm}
			Dostęp do pamięci odbywa się za pomocą instrukcji {\it load/store}. W instrukcjach {\it load} adres bazowy znajduje się w rejestrze {\it rs1}, offset jest pobierany z liczby całkowitej 12bitowej {\it imm}. Rejestr docelowy znajduje się w {\it rd}. Przykład działania instrukcji {\it LW}:
			\begin{flushleft}			
			{\fontfamily{qcr}\selectfont
			lw x16, 8(x2)\\
			\begin{tabular}{*{5}{|c}|}
				\hline
				imm[11:0] & rs1 & func3 & rd & opcode\\
				\hline
				offset[11:0] & base\_addr & width & dst\_addr & LOAD\\
				\hline
				000000001000 & 00010 & 010 & 10000 & 0000011\\
				imm=+8 & rs1=2 & LW & rd=16  & LOAD\\
				\hline
			\end{tabular}
			}
			\end{flushleft}
			Wartość w {\it funct3} służy do dekodowania rozmiaru i znaku ładowanej wartości. Wartość ta jest zależna od użytego rozkazu, tabela \ref{Tab:load_instr} przedstawia zależność między instrukcją a wartością {\it func3}. 
			\begin{center}
			\captionof{table}{Zależność między {\it func3} a instrukcją load\label{Tab:load_instr}\cite{isa_book}}\small
				\begin{tabular}{|c|c|}
					\hline
					func3 & instrukcja \\
					\hline
					000 & LB \\
					\hline
					001 & LH \\
					\hline
					010 & LW \\
					\hline
					100 & LBU \\
					\hline
					101 & LHU \\
					\hline
				\end{tabular}
		\end{center}
		Kolejnymi instrukcjami są rozkazy {\it store}. Potrzebują one dwóch rejestrów, rejestr {\it rs1} zawiera bazowy adres pamięci, natomiast do rejestru {\it rs2} zostanie ona przypisana. Wartość offsetu jest pobierana z {\it imm}. Przykład działania instrukcji {\it SW}:
		\begin{flushleft}			
			{\fontfamily{qcr}\selectfont
			sw x16, 8(x2)\\
			\begin{tabular}{*{6}{|c}|}
				\hline
				imm[11:5] & rs2 & rs1& func3 & imm[4:0] & opcode\\
				\hline
				offset[11:5] & store\_addr & base\_addr & width & offset[4:0] & STORE\\
				\hline
				00000000 & 10000 & 00010 & 010 & 01000 & 0100011\\
				imm[11:0]=+8 & rs2=16 & rs1=2 & SW & & STORE\\
				\hline
			\end{tabular}
			}
			\end{flushleft}
			Podobnie jak w instrukcjach {\it load} func3 służy dekodowania rozmiaru i jest zależna od przekazanego rozkazu. Tabela \ref{Tab:store_instr} przedstawia tą zależność.
			\begin{center}
			\captionof{table}{Zależność między {\it func3} a instrukcją store\label{Tab:store_instr}\cite{isa_book}}\small
				\begin{tabular}{|c|c|}
					\hline
					func3 & instrukcja \\
					\hline
					000 & SB \\
					\hline
					001 & SH \\
					\hline
					010 & SW \\
					\hline
				\end{tabular}
		\end{center}
		\subsubsection{Instrukcje arytmetyczne i logiczne}
		\hspace{5mm}
			RISC-V zawiera zestaw instrukcji matematycznych przeznaczony dla liczb całkowitych w którego skład wchodzą: dodawanie, odejmowanie, przesuwanie , operacje logiczne i porównywanie liczb. Instrukcje dla mnożenia i dzielenia liczb znajdują się w rozszerzeniu ISA {\it M}. Zaś rozszerzenie ISA {\it F} zawiera instrukcje matematyczne dla liczb zmiennoprzecinkowych pojedynczej precyzji, rozszerzenie {\it D} zawiera instrukcje matematyczne dla liczb zmiennoprzecinkowych podwójnej precyzji\cite{isa_book}. Instrukcje te wykorzystują format {\it R} i {\it I}. Przykład działania rozkazu {\it add}, wykorzystuje on format instrukcji {\it R}:
			\begin{flushleft}			
			{\fontfamily{qcr}\selectfont
			add x6, x7, x8\\
			\begin{tabular}{*{6}{|c}|}
				\hline
				funct7 & rs2 & rs1 & func3 & rd & opcode\\
				\hline
				0000000 & 01000 & 00111 & 000 & 00110 & 0110011\\
				\hline
			\end{tabular}
			}
			\end{flushleft}
Pierwszy argument trafił to rejestru {\it rd}, kolejny do rejestru {\it rs1} ostatni do rejestru {\it rs2}. {\it Funct7} i {\it funct3} służą do rozpoznania operacji i są one zależne od przekazanej instrukcji. Tabela \ref{Tab:add_instr} przedstawia te zależności.
			\begin{center}
			\captionof{table}{Zależność między {\it func7} i {\it func3} a instrukcjami arytmetycznymi\label{Tab:add_instr}\cite{isa_book}}\small
				\begin{tabular}{|c|c|c|c|}
					\hline
					func7 & func3 & OPCODE & instrukcja \\
					\hline
					0000000 & 000 & 0110011 & ADD \\
					\hline
					0100000 & 000 & 0110011 & SUB \\
					\hline
					0000000 & 001 & 0110011 & SLL \\
					\hline
					0000000 & 010 & 0110011 & SLT \\
					\hline
					0000000 & 011 & 0110011 & SLTU \\
					\hline
					0000000 & 100 & 0110011 & XOR \\
					\hline
					0000000 & 101 & 0110011 & SRL \\
					\hline
					0100000 & 101 & 0110011 & SRA \\
					\hline
					0000000 & 110 & 0110011 & OR \\
					\hline
					0000000 & 111 & 0110011 & AND \\
					\hline
				\end{tabular}
		\end{center}
		Instrukcja {\it addi} wykorzystuje format {\it I}, więc trzeci argument rozkazu jest liczbą całkowitą. Przykład tej instrukcji: 
			\begin{flushleft}			
			{\fontfamily{qcr}\selectfont
			addi x6, x0, 50\\
			\begin{tabular}{*{5}{|c}|}
				\hline
				imm[11:0] & rs1 & func3 & rd & opcode\\
				\hline
				000000110010 & 00000 & 000 & 00110 & 0010011\\
				\hline
			\end{tabular}
			}
			\end{flushleft}
			{\it Func3} jest wykorzystywana w celu dekodowania instrukcji. Rozkazu przesunięcia bitowego wykorzystują pięć najmłodszych bitów z {\it imm}. Siedem pozostałych bitów służy do rozpoznawania instrukcji.
		\subsubsection{Instrukcje skokowe}
		\hspace{5mm}
			Instrukcje skokowe dzielą się na dwa rodzaje: skoki bezwarunkowe i skoki warunkowe. Pierwszą z nich reprezentują dwa rozkazy: \textit{JAL} (format \textit{UJ} i \textit{JALR} (format \textit{I}. Pierwszy z nich pozwala dodać do rejestru PC liczbę ze znakiem o szerokości 20bitów. Dzięki rozkazowi \textit{JALR} i \textit{AUIPC} można stworzyć skok o szerokości 32bitów. Rozkaz \textit{AUIPC} zapisuje do rejestru aktualną wartość PC, a rozkaz \textit{JALR}, zamienia dwanaście najmłodszych bitów na wartość przekazanego argumentu. Przykładowe programy z użyciem instrukcji skoków bezwarunkowych.
				\begin{lstlisting}[language=Ant]
addi x31, x0 ,0
auipc x2, 0
addi x31, x31, 1
addi x31, x31, 2
jalr x1, x2, 8
			\end{lstlisting}
			Program wpisuje do rejestru \textit{x2} aktualną wartość PC, następnie po wykonaniu dwóch instrukcji \textit{addi} następuje rozkaz\textit{jalr}, który dodaje wartość 8 do zapisanej wartości PC, więc kolejnym rozkazem wykonanym będzie \textit{addi x31, x31, 2}.
			\\
			Kolejną rodzajem są skoki warunkowe, jest ich sześć i są zakodowane w formacie \textit{SB}:
			\begin{itemize}
				\item BEQ - gdy zapisane liczby w rejestrach są równe wykonuje skok
				\item BNE - gdy zapisane liczby w rejestrach są różne wykonuje skok
				\item BLT - gdy liczba z rejestru \textit{rs1} jest większa wykonuje skok
				\item BLTU - gdy liczba z rejestru \textit{rs1} jest większa bądź równa wykonuje skok
				\item BHE - gdy liczba z rejestru \textit{rs2} jest większa wykonuje skok
				\item BGEU - gdy liczba z rejestru \textit{rs2} jest większa wykonuje skok
			\end{itemize}
	\subsection{System on Chip}

		\subsubsection{Architektura Harvardzka}
		\hspace{5mm}
			Architektura Harvardzka to rodzaj architektury komputera. Posiada ona dwie oddzielne szyny dla danych i rozkazów. Można w tym samym czasie pobierać argument wykonywanej funkcji i pobierać następnego rozkazu. Zwiększa ta szybkość pracy. Rysunek \ref{Fig:harvard} przedstawia schemat blokowy tej architektury.\\
\begin{samepage}
			\captionof{figure}{Schemat blokowy architektury Harvardzkiej\label{Fig:harvard}}
\nopagebreak
\begin{center}
		\includegraphics[width=10cm]{./rysunki/Harvard_architecture.png}
		\end{center}
\end{samepage}
		\subsubsection{Peryferia}
		\hspace{5mm}
			W projekcie zostały dodane następujące peryferia:
			\begin{enumerate}
			\item RAM - pamięć o dostępnie swobodnym, jest to podstawowy rodzaj pamięci cyfrowej. Może być ona odczytywana i zmieniana w dowolnej kolejności. Służy ona do przechowywania danych i kodu maszynowego. W projekcie zaimplementowano pamięć jedno-portową i dwu-portową. Pamięć jedno-portowa posiada tylko jeden dane/adres port, więc może być czytana lub zapisywana w jednej chwili czasu. Pamięć dwu-portowa zawiera dwa dane/adres porty, więc może być czytana i zapisywana w jednej chwili czasu.\cite{ram_book}
			\item SPI - interfejs służący do transmisji, głównie używany w systemach wbudowanych. Wykorzystuje się tryb \textit{master-slave}, dzięki temu jest zapewniona komunikacja full-duplex. Interfejs ten posiada następujące porty:
			\begin{itemize}
			\item $SCLK$ - zegar, wyjście z mastera.
			\item $MOSI$ - \textit{Master Out Slave In}
			\item $MISO$ - \textit{Master In Slave Out}
			\item $\overline{SS}$ - \textit{Slave Select}
			\end{itemize}
			 By rozpocząć transmisje, \textit{Master} konfiguruje \textit{SCLK}, następnie ustawia stan niski na \textit{SS} w celu wybrania odpowiedniego \textit{Slave'a}. \textit{Master} wysyła bit poprzez \textit{MOSI} i \textit{slave'a} odczytuje go i wysyła bit poprzez \textit{MISO}. Rysunek \ref{Fig:spi} obrazuję przebieg transmisji\cite{spi_book}.\\
			\begin{minipage}{\textwidth}
				\captionof{figure}{Przykład transmisji SPI\label{Fig:spi}}
				\begin{center}
					\includegraphics[width=13cm]{./rysunki/spi.png}
				\end{center}
			\end{minipage}
			
			\item I2C - magistrala szeregowa, dwukierunkowa, synchroniczna służąca do komunikacji. Wykorzystuje tryb \textit{master-slave}. Posiada dwa porty:
			\begin{itemize}
				\item SDA - Linia dla \textit{mastera} i \textit{slave'a} służąca do komunikacji między nimi
				\item SCL - linia przenosząca sygnał zegarowy
			\end{itemize}
			I2C może pracować z wieloma \textit{slave'ami} i \textit{masterami}. Rysunek \ref{Fig:i2c_frame} przedstawia wygląd ramki I2C. By rozpoacząć transmisje \textit{master} wysyła sygnał startowy. By to uzyskać sygnał na linii \textit{SDA} zmienia się z wysokiego na niski przed zmianą sygnały z wysokiego na niski na linii \textit{SCL}. Następnie jest przesyłany adres \textit{slave'a}. \textit{Slave} porównuje nadesłany adres i odsyła bit \textit{ACK} ustawiając na linii \textit{SDA} bit na stan niski. Po każdej udanej transmiji \textit{slave} przysyła \textit{masterowi} bit \textit{ACK}. W celu zakończenia transmisji należy w czasie wysokiego stanu \textit{SCL} zmienić stan z niskiego na wysoki na linii \textit{SDA}. Rysunek \ref{Fig:i2c_trans} przedstawia przykładowy przebieg transmisji.\cite{i2c_book}


			\item UART - urządzenie służące do asynchronicznej szeregowej komunikacji. Odbiera jak i wysyła informacje poprzez port szeregowy. Zawiera on on konwertery:
			\begin{itemize}
				\item szeregowo-równoległy - do konwersji danych wysyłanych do komputera
				\item równoległy-szeregowy - do konwersji danych pochodzących z komputera
			\end{itemize}	
			Rysunek \ref{Fig:uart_frame} przedstawia ramkę UARTu. Bit parzystości jest opcjonalny i służy jako bit kontrolny.\cite{uart_book}
			\begin{samepage}
				\captionof{figure}{Ramka UART\label{Fig:uart_frame}}
				\nopagebreak
				\begin{center}
					\includegraphics[width=13cm]{./rysunki/uart_frame.png}
				\end{center}
			\end{samepage}
			\item GPIO - wyprowadzenia służące do komunikacja między mikroprocesorem a peryferiami \cite{gpio_doc}
			\item Timer
			\end{enumerate}

		\subsubsection{Wishbone}
		\hspace{5mm}
			Wishobone to opensource magistrala służąca do łączenia ze sobą wielu IP w systemie \textit{master/slave}. Rysunek \ref{Fig:wishbone} przedstawia połączenia w tym interfejsie.\\
			\begin{minipage}{\textwidth}
				\captionof{figure}{Wishbone master/slave interfejs\cite{wishbone_b4}\label{Fig:wishbone}}
				\nopagebreak
				\begin{center}
					\includegraphics[width=10cm]{./rysunki/wishbone.png}
				\end{center}
			\end{minipage}
			Podczas implementacji tej magistrali należy trzymać się zasad które definiuje standard:
			\begin{itemize}
				\item Wszystkie sygnały interfejsu muszą być aktywne w wysokim stanie
				\item Wszystkie interfejsy \textit{WISHOBONE} muszą zainicjować siebie podczas asercji sygnału \textit{RST\_I}. Muszą zostać zainicjowane aż do narastającego zbocza \textit{CLK\_I}, której następuje po negacji \textit{RST\_I}.
				\item \textit{RST\_I} musi pozostać przynajmniej przez jeden pełny cykl zegarowy w stanie asercji.
				\item Wszystkie interfejsy \textit{WISHBONE} muszą być przygotowane na reakcję na \textit{RST\_I} w każdym momencie.
				\item \textit{RST\_I} może pozostać w stanie asercji dłużej niż jeden cykl zegarowy.
			\end{itemize}
			Porty używane przez ten interfejs\cite{wishbone_tutorial}:
			\begin{itemize}
				\item \textit{RST\_I} - sygnał resetu otrzymywany z \textit{SYSCON}
				\item \textit{CLK\_I} - sygnał zegarowy otrzymywany z \textit{SYSCON}
				\item \textit{ADR\_O/I} - linia adresu, wyjście z \textit{mastera}, wejście do \textit{slave'a}
				\item \textit{DAT\_I/O} - linia danych 
				\item \textit{WE\_O/I} - pozwolenie na zapis, wyjście z \textit{master}, wejście do \textit{slave}.
				\item \textit{SEL\_O/I} - selekcja bajtu, wyjście z \textit{master}, wejście do \textit{slave}.
				\item \textit{STB\_O/I} - potwierdzenie nadania danych przez \textit{mastera}, wyjście z \textit{master}, wejście do \textit{slave}.
				\item \textit{ACK\_I/O} - potwierdzenie przyjęcia danych przez \textit{slave'a}, wyjście z \textit{slave}, wejście do \textit{master}.
				\item \textit{CYC\_O/I} - cykl magistrali, wyjście z \textit{master}, wejście do \textit{slave}.
			\end{itemize}
			
		Są dostępne trzy topologie:
			\begin{enumerate}
				\item Data Flow Interconnection
				\item Crossbar Switch Interconnection
				\item Shared Bus Interconnection
			\end{enumerate}
			Ostatnia topologia została użyta w projekcie. Ma ona miejsce gdy wiele peryferii typu \textit{slave} jest podpięta do tych samych \textit{masterów}. Rysunek \ref{Fig:wishbone_sharedbus} przedstawia przykład tej topologii.
			\begin{samepage}
				\captionof{figure}{Wishbone shared bus interconnection\cite{wishbone_b4}\label{Fig:wishbone_sharedbus}}
				\nopagebreak
				\begin{center}
					\includegraphics[width=10cm]{./rysunki/wishbone_sharedbus.png}
				\end{center}
			\end{samepage}
		W celu rozpoznania odpowiedniego \textit{slave'a} przypisuje im się adresy. Adresy te tworzą mapę, szczegółowy opis tejże mapy znajduje się w rozdziale 3.2.
	\subsection{Ibex}
	\hspace{5mm}
		Ibex jest to mikroprocesor tworzony przez organizację \textit{LowRISC}. Jest on dwupotokowy:
\begin{enumerate}
	\item Pobieranie instrukcji - pobiera instrukcje z pamięci.
	\item Dekodowanie i wykonanie instrukcji - zdekodowanie pobranej instrukcji i natychmiastowe jej wykonanie
\end{enumerate}		
		 Implementuje on \textit{ISA RV32IMC}. Wspiera on również rozszerzenie \textit{E} i eksperymentalne \textit{B}. Można je włączyć poprzez prawidłowe ustawienie parametrów\cite{ibex_doc}. Mikroprocesor ma szeroko rozwiniętą weryfikacje, wykorzystuje on między innymi generator rozkazów \textit{RISCV-DV}. Jest on również częścią projektu \textit{OpenTitan}, jest to \textit{RoT}, wspierany między innymi przez \textit{Google}\cite{google_opentitan}.
		Rysunek \ref{Fig:ibex_block} przedstawia schemat blokowy mikroprocesora \textit{Ibex}\cite{ibex_doc}.\\
			\begin{minipage}{\textwidth}
				\captionof{figure}{Schemat blokowy mikroprocesora\label{Fig:ibex_block}}
				\nopagebreak
				\begin{center}
					\includegraphics[width=14cm]{./rysunki/blockdiagram.png}
				\end{center}
			\end{minipage}
	\subsection{Kompilator}
		\subsubsection{Budowanie toolchaina}
		\hspace{5mm}
			Toolchain można pobrać z oficjalnego repozytorium \textit{RISC-V}\cite{toolchain}. By zbudować kompatibilną wersję kompilatora dla mikroprocesora \textit{Ibex}, należy do konfiguracji podać argumenty \textit{--with-abi=ilp32 --with-arch=rv32imc --with-cmodel=medany} lub skorzystać z \textit{--multilib}. Opcja ta spowoduje zbudowanie kompilatora dla 64bit, lecz po podaniu odpowiednich argumentów podczas kompilacji programu wspiera również architektury 32bit.
		\subsubsection{Przykładowa kompilacja}
		\hspace{5mm}
			By skompilować przykładowy program dla mikroprocesora 
			\textit{Ibex} należy użyć następujących komend: \\
\begin{minipage}{\textwidth}
\begin{scriptsize}
\begin{lstlisting}[label=Lis:kompilacja,caption=Przykładowa kompilacja]
riscv32-unknown-elf-gcc -march=rv32imc -mabi=ilp32 -static -mcmodel=medany -nostdlib \
-nostartfiles -Wall -g -Os -MMD -c  -o led.o led.c

riscv32-unknown-elf-gcc -march=rv32imc -mabi=ilp32 -static -mcmodel=medany -nostdlib \
-nostartfiles -Wall -g -Os -MMD -c  -o crt0.o crt0.S

riscv32-unknown-elf-gcc -march=rv32imc -mabi=ilp32 -static -mcmodel=medany -nostdlib \
-nostartfiles -Wall -g -Os -T link.ld led.o crt0.o -o led.elf 

riscv32-unknown-elf-objcopy -O binary led.elf led.bin

srec_cat led.bin -binary -offset 0x0000 -byte-swap 4 -o led.vmem -vmem

riscv32-unknown-elf-objcopy -O verilog --interleave-width=4 \
--interleave=4 --byte=0 led.elf led.hex
\end{lstlisting}
\end{scriptsize}
\end{minipage}
Pierwsze dwie komendy tworzą biblioteki, trzecia komenda spaja ze sobą potrzebne biblioteki i konsolidatora i tworzy plik \textit{bin}. Następnie plik \textit{bin} jest konwertowany do plików \textit{vmem} i \textit{hex}.
	\subsection{Weryfikacja}

		\subsubsection{UVM}
		\hspace{5mm}
			UVM jest to biblioteka oparta na języku \textit{SystemVerilog} służąca do tworzenia testów weryfikacyjnych. UVM zawiera bazowe klasy z metodami, które pomagają w weryfikacji. Ważniejsze klasy bazowe biblioteki:
			\begin{enumerate}
				\item uvm\_object - podstawowa klasa bazowa, zawierająca metody: \textit{create, copy, clone, compare, print, record}. Zazwyczaj używana do budowy testbenchu i konfiguracji testcase'u
				\item uvm\_component - wszystkie komponenty testbenchu takie jak \textit{scoreboards, monitor, driver} pochodzą z tej klasy.
				\item uvm\_sequence - jest klasą bazową wszystkich sekwencji zawartych w testbenchu
			\end{enumerate}
UVM test składa się z następujących elementów:
\begin{itemize}
	\item UVM test - jest odpowiedzialny za konfigurację testbenchu, rozpoczęcie symulacji poprzez inicjalizację sekwencji, stworzenie wszystkich komponentów, której znajdują się poniżej w hierarchii na przykład: uvm\_env.
	\item UVM env - grupuje agentów i scoreborady
	\item UVM Agent - łączy ze sobą \textit{uvm\_components} na przykład:\textit{uvm\_driver, uvm\_monitor, uvm\_suquence, uvm\_sequencer} za pomocą interfejsów TLM.
	\item UVM Driver - jest odpowiedzialny za wysyłanie pakietów do DUT
	\item UVM Sequence - generuje pa kiety
	\item UVM Sequencer - jest odpowiedzialny za ruch między \textit{uvm\_sequence} i \textit{uvm\_driver}
	\item UVM Monitor - obserwuje sygnały, następnie wysyła je do \textit{uvm\_scoreboard}
	\item UVM Scoreboard - odbiera dane z \textit{uvm\_monitor} i porównuje z spodziewanymi wartościami. Wartości te mogą pochodzić z modelu referencyjnego lub \textit{golden pattern}.
\end{itemize}
		Rysunek \ref{Fig:uvm_block} przedstawia przykładowy graf UVM testu
			\begin{samepage}
				\captionof{figure}{Przykładowy graf UVM\label{Fig:uvm_block}}
				\nopagebreak
				\begin{center}
					\includegraphics[width=14cm]{./rysunki/uvm_graph.jpg}
				\end{center}
			\end{samepage}
		\subsubsection{RISCV DV}
		\hspace{5mm}
			RISCV-DV - narzędzie/IP służące do generacji programów w języku assembler do testowania danych aspektów procesora. Współpracuje z ISA: \textit{RV32IMAFDC, RV64IMAFDC}. Programy są tworzone losowo. By korzystać z tego nardzędzia/IP należy posiadać symulator wspierający UVM, na przykład: Riviera-PRO \cite{google_dv}.

	\subsection{FPGA}
	\hspace{5mm}
		SoC będzie działać na płytce NEXYS4 DDR wyposażony w programowalny układ logiczny Artix-7 XC7A100T-1CSG324C. Ważniejsze zasoby płytki:\cite{nexys}
		\begin{itemize}
			\item 15850 plastrów logicznych, każdy złożony z czterech elementów LUT o 6-wejściach i 8 przerzutników
			\item Pojemność 4860 kb szybkiego bloku pamięci RAM
			\item Sześć bloków zarządzania sygnałem zegarowym (CMT), każdy z pętlą fazową (PLL)
			\item 240 plastrów DSP
			\item 16 przełączników użytkownika
			\item Mostek USB-UART
			\item Port USB-JTAG Digilent do komunikacji i programowania FPGA
			\item Cztery porty Pmod
			\item 100MHz rezonator kwarcowy
		\end{itemize}

	\subsection{SystemVerilog}
	\hspace{5mm}
		Język opisu sprzętu, jest rozszerzeniem języka Verilog. Dodaje on nowe typy danych: \textit{logic, enum, byte, shortint, int, longint, struct, union}, wielowymiarowe tablice. Dodano również nowe bloki proceduralne: \textit{always\_comb, always\_latch, always\_ff}. Wprowadzono interfejsy wraz z \textit{modportami}, pomagają one zapanować nad portami w projekcie. Udoskonalono weryfikację poprzez dodanie nowego typu danych: \textit{string}, klas, asercji oraz \textit{constrained random generation} pozwalający narzucić ograniczenia podczas randomizacji.\cite{SV}
			
			\subsubsection{Xilinx Vivado Design Suite}
			\hspace{5mm}
				Vivado Design Suite - oprogramowanie firmy Xilinx dla syntezy i analizy projektów HDL. Posiada wbudowany symulator \textit{ISIM} oraz \textit{Vivado IP Integrator} pozwalający na szybkie zarządzanie IP.
				
			\subsubsection{Aldec Riviera-PRO}
			\hspace{5mm}
				Riviera-PRO komercyjny symulator HDL firmy Aldec. Obsługuje on bibliotekę UVM, randomizacje, asercje oraz może być wykorzystany do generacji programów assembler w celu weryfikacji działania SoCa.
				
\newpage

\section{Implementacja}

	\subsection{System na czipie}
	\hspace{5mm}
	Modułem głównym projektu jest \textit{ibex\_soc}. Nazwy jego portów, parametru i ich przeznaczenie zostały przedstawione w tabeli \ref{Tab:soc_ports}

			\begin{center}
			\captionof{table}{Porty i parametry modułu \textit{ibex\_soc}\label{Tab:soc_ports}}\small
				\begin{tabular}{|c|c|c|}
					\hline
					typ parametru/kierunek portu & nazwa parametru / portu & przeznaczenie \\
					\hline
					localparam & SPI\_SLAVE\_NUMBER & ilość portów SS SPI \\
					\hline
					input & I\_CLK & wejście sygnału zegarowego  \\
					\hline
					input & I\_RST\_N & wejście sygnału resetu \\
					\hline
					output & O\_LED & wyjście GPIO \\
					\hline
					input & I\_BTM & wejście GPIO \\
					\hline
					input & I\_UART\_RX & wejście UART receive \\
					\hline
					output & O\_UART\_TX & wyjście UART transmit \\
					\hline
					inout & IO\_SDA & dwukierunkowa linia danych I2C \\
					\hline		
					inout & IO\_SCL & dwukierunkowa linia zegara I2C \\
					\hline	
					input & I\_MISO & wejście Master In Slave Out SPI \\
					\hline		
					input & I\_MOSI & wejście Master Out Slave In SPI \\
					\hline	
					output & O\_MOSI & wyjście Master Out Slave In SPI \\
					\hline		
					output & O\_MISO & wyjście Master In Slave Out SPI \\
					\hline																			output & O\_SCK & wyjście linii zegara SPI \\
					\hline	
					input & I\_SCK & wejście linii zegara SPI \\
					\hline		
					input & I\_CS & wejście wyboru slave SPI \\
					\hline		
					output & O\_CS & wyjście wyboru slave SPI \\
					\hline				
				\end{tabular}
		\end{center}
Parametr \textit{SPI\_SLAVE\_NUMBER} definiuje ilość wyjść wybory slave. Wejście sygnału zegarowego zostało podłączone do rezonatora kwarcowego o częstotliwości 100MHz. Wejście resetu zostało podłączone do przełącznika znajdującego się na płytce FPGA, jest on aktywny w stanie niskim. Sygnały \textit{GPIO} zostały podłączone do diod LED oraz przełączników. Sygnały \textit{UART} zostały podłączone do znajdującego się na płytce konwertera \textit{USB-UART}. Pozostałe sygnały zostały połączone z portami \textit{Pmod}.
\\
Tabela \ref{Tab:instancje_soc} przedstawia nazwy modułów i odpowiadające im instancje, zainicjowane w \textit{ibex\_soc}.

			\begin{center}
			\captionof{table}{Instancje modułów znajdujących się w \textit{ibex\_soc}\label{Tab:instancje_soc}}\small
				\begin{tabular}{|c|c|c|}
					\hline
					nazwa modułu/interfejsu & nazwa instancji & przeznaczenie \\
					\hline
					clkgen & clkgen & buforowanie sygnału zegarowego oraz jego skalowanie \\
					\hline
					ibex\_wb & ibex\_wishbone & wraper rdzenia Ibex przystosowany do interfejsu \textit{Wishbone}  \\
					\hline
					wishbone\_sharedbus & wb\_share\_bus & komunikacja masterów ze slave'ami \\
					\hline
					wb\_1p\_ram\_instr & ram\_instr & jednoportowa pamięć RAM przeznaczona dla instrukcji \\
					\hline
					wb\_1p\_ram\_data & ram\_data & jednoportowa pamięć RAM przeznaczona dla danych \\
					\hline
					wb\_2p\_ram\_instr & ram\_instr & dwuportowa pamięć RAM przeznaczona dla instrukcji \\
					\hline
					wb\_2p\_ram\_data & ram\_data & dwuportowa pamięć RAM przeznaczona dla danych \\
					\hline
					wb\_gpio & wb\_gpio & wraper GPIO przystosowany do interfejsu \textit{Wishbone} \\
					\hline		
					wb\_uart & wb\_uart & wraper UART przystosowany do interfejsu \textit{Wishbone} \\
					\hline	
					wb\_i2c & wb\_i2c & wraper I2C przystosowany do interfejsu \textit{Wishbone} \\
					\hline		
					wb\_spi\_master & wb\_spi\_master & wraper SPI master przystosowany do interfejsu \textit{Wishbone} \\
					\hline	
					wb\_spi\_slave & wb\_spi\_slave & wraper SPI slave przystosowany do interfejsu \textit{Wishbone} \\
					\hline		
					wb\_timer & wb\_timer & wraper timera przystosowany do interfejsu \textit{Wishbone} \\
					\hline			
					wishbone\_if & wb\_master & tablica interfejsów przeznaczona dla rdzenia \\
					\hline		
					wishbone\_if & wb\_slave & tablica interfejsów przeznaczona dla peryferii \\
					\hline													
				\end{tabular}
		\end{center}

Szczegółowy opis powyższych modułów znajduje się w kolejnych podrozdziałach. 
Moduł ten importuje również paczkę z mapą pamięci. Są w niej zdefiniowane parametry opisujące adres bazowy jak i rozmiar. Listing \ref{Lis:memory-map} przedstawia te parametry.

\begin{minipage}{\textwidth}
\begin{scriptsize}
\begin{lstlisting}[label=Lis:memory-map,caption=Mapa pamięci]
package addr_map_pkg;

	parameter NUM_MASTER = 2;
	parameter NUM_SLAVE = 7;
	parameter RAM_INSTR_BASE_ADDR   = 'h00000000;
	parameter RAM_INSTR_SIZE        = 'h10000;
	parameter RAM_DATA_BASE_ADDR    = 'h00100000;
	parameter RAM_DATA_SIZE         = 'h10000;
	parameter LED_BASE_ADDR         = 'h10000000;
	parameter LED_SIZE              = 'h0fff;
	parameter UART_BASE_ADDR        = 'h10001000;
	parameter UART_SIZE             = 'h0fff;
	parameter I2C_BASE_ADDR         = 'h10002000;
	parameter I2C_SIZE              = 'h0fff;
	parameter SPI_BASE_ADDR         = 'h10003000;
	parameter SPI_SIZE              = 'h0fff;
	parameter TIMER_BASE_ADDR       = 'h10004000;
	parameter TIMER_SIZE            = 'h0fff;

endpackage
\end{lstlisting}
\end{scriptsize}
\end{minipage}
Parametr \textit{NUM\_MASTER} definiuje ilość \textit{masterów} w projekcie. Są dwa, pierwszy przeznaczony dla linii danych rdzenia, drugi przeznaczony dla linii instrukcji rdzenia. Parametr \textit{NUM\_SLAVE} definiuje ilość użytych peryferii. Parametry te służą również do określenia wielkości tablic instancji interfejsu \textit{wishbone\_if}.
	\subsection{Rdzeń Ibex}
	\subsubsection{\textit{Ibex wishbone}}
	\hspace{5mm}
		Głównym modułem rdzenia jest \textit{ibex\_core}. By poprawnie działał z magistralą \textit{Wishbone}, należy opisać \textit{wrapper} w odpowiedni sposób. W tym celu powstał moduł \textit{ibex\_wishbone}, jego zadaniem jest poprawne przeniesienie sygnałów do interfejsów magistrali \textit{Wishbone}. Zostały w nim zainicjowane następujące moduły/interfejsy:
\begin{itemize}
	\item \textit{data\_core} - interfejs \textit{ibex\_if} z sygnałami danych.
	\item \textit{instr\_core} - interfejs \textit{ibex\_if} z sygnałami instrukcji.
	\item \textit{u\_core} - instancja modułu \textit{ibex\_core}
	\item \textit{data\_core2wb} - instancja modułu \textit{ibex\_to\_wb}
	\item \textit{instr\_core2wb} - instancja modułu \textit{ibex\_to\_wb}
\end{itemize}		
Wykorzystuje on przypisanie ciągłe by w instancji \textit{instr\_core} wymusić stan niski na sygnałach: \textit{we}, \textit{be} i \textit{wdata} w celu zabezpieczenia przypadkowego zapisu w pamięci instrukcji.
			
	\subsubsection{\textit{Data core} i \textit{Instr core}}
	\hspace{5mm}
\textit{Data\_core} i \textit{instr\_core} są to instancje interfejsu \textit{ibex\_if}. Są w nich zdefiniowane sygnały pochodzące z linii instrukcji i linii danych. Interfejs ten zawiera w sobie dwa modporty: \textit{master} i \textit{slave}. W zależności od potrzeby możemy odczytywać wartości sygnałów używając modportu \textit{slave}, modport \textit{master} daje możliwość zapisywania wartości sygnałów. \mbox{Tabela \ref{Tab:interface_port}} przedstawia listę sygnałów wraz z ich kierunkami w zależności od używanego modportu.

\begin{minipage}{\textwidth}
\begin{center}
			\captionof{table}{Porty i parametry modułu \textit{ibex\_soc}\label{Tab:interface_port}}\small
				\begin{tabular}{|c|c|c|c|}
					\hline
					\multicolumn{2}{|c|}{Kierunek wyprowadzenia} & \multirow{2}{*}{Nazwa wyprowadzenia} & \multirow{2}{*}{Przeznaczenie}\\
					\cline{1-2}
					Modport master & Modport slave & & \\ 
					\hline
					input & input & clk\_i & sygnał zegarowy \\
					\hline
					input & input & rst\_ni & sygnał resetu \\
					\hline
					output & input & reg & żądanie zapytania\\
					\hline
					input & output & gnt & sygnał akceptacji zapytania\\
					\hline
					input & output & rvalid & sygnał prawidłowego odczytu danych\\
					\hline
					output & input & we & zezwolenie zapisu\\
					\hline
					output & input & be & sygnał bajtu\\
					\hline
					output & input & addr & sygnał adresowy\\
					\hline
					output & input & wdata & dane przeznaczone do zapisu\\
					\hline
					input & output & rdata & odczytane dane\\
					\hline
					input & output & err & sygnał błędu\\
					\hline
				\end{tabular}
		\end{center}
		\end{minipage}
	\subsubsection{\textit{Ibex core}}
	\hspace{5mm}
		Moduł \textit{ibex\_core} został zainjonowany jako \textit{u\_core}. Zawiera on w sobie wszystkie submoduły rdzenia,a są to:
\begin{itemize}
	\item \textit{Clock gating} - moduł zawierający bufor sygnału zegarowego.
	\item \textit{Instruction Fetch} - odpowiedzialny za pobieranie instrukcji. W jednym cyklu dostarcza instrukcję do \textit{ibex\_id\_stage} o ile pamięć jest zdolna do wysłania jednej instrukcji na cykl. Instrukcje są przechwytywane do \textit{ibex\_prefetch\_buffer} w celu optymalizacji wydajności. Rozkazy są zapisywane wraz licznikiem rozkazów i pochodzą z \textit{ibex\_fetch\_fifo}. Gdy  \textit{FIFO} jest puste, instrukcja natychmiast zostaje przekazana na jego wyjście.
	\item \textit{Instruction Decode} - odpowiedzialny za dekodowanie instrukcji. Zawiera on w sobie multipleksery, kontrolujące przepływ danych do \textit{ALU},
	\item \textit{Instruction Execute} - odpowiedzialny za wykonanie instrukcji, zawiera on w sobie \textit{ALU} i moduły odpowiedzialne za mnożenie i dzielnie. 
	\begin{itemize}
		\item \textit{Arithmetic Logic Unit} - jednostka arytmetyczno-logiczna, blok kombinacyjny wykonujący obliczenia liczb całkowitych oraz operacje porównawcze.
		Dodatkowo jest wykorzystywany:
		\begin{itemize}
			\item w wykonywaniu dodawania w ramach algorytmów mnożenia i dzielenia
			\item w obliczaniu \textit{PC}+\textit{Imm}
			\item w obliczaniu adresu pamięci \textit{Reg}+\textit{Imm}
		\end{itemize}
		\item \textit{Multiplier/Divider Block} - blok wykorzystywany do mnożenia i dzielenia. Są dostępne dwa tryby: szybki i wolny. Oba wykorzystują algorytm długiego podziału oraz jednostkę arytmetyczno-logiczną.
	\end{itemize}
	\item \textit{Load-Store Unit} - odpowiedzialny za dostęp do pamięci danych. Pozwala działać na słowach (32-bit) pół-słowach(16-bit) i bajtach(8-bit). Każda operacja zapisania lub odczytu danych powoduje zatrzymacie bloków \textit{ID/EX} na przynajmniej jeden cykl w celu oczekiwania na odpowiedź. Potrafi obsłużyć źle   ustawiony dostęp do pamięci, czyli dostęp, który nie jest w domyślnych granicach słowa. Potrzeba na to co najmniej dwóch cykli ponieważ są robione dwa osobne zapisania. Komunikacja z pamięcią odbywa się w następujący sposób:
		\begin{enumerate}
			\item Jednsotka LSU wysyła adres poprzez \textit{data\_addr\_o}, konfiguruje wyjścia \textit{data\_be\_o}, \textit{data\_wdata\_o}, ustawia stan wysoki sygnału \textit{data\_req\_o} i \textit{data\_we\_o}. Gdy pamięć będzie gotowa do obsługi żądania, odpowiada stanem wysokim sygnału \textit{data\_gnt\_i}.
			\item Po otrzymaniu potwierdzenia gotowości, \textit{LSU} może zmienić wartość sygnału \textit{data\_addr\_o}.
			\item Pamięć wysyła wysoki stan sygnału \textit{data\_rvalid\_i} wraz z informacją o wystąpieniu błędów, jeśli takowe się pojawią zostanie to zasygnalizowane stanem wysokim sygnału \textit{data\_err\_i}. Odczytane dane są przekazywane dostępne na linii \textit{data\_rdata\_i}.
			\item W przypadku wielu żądań, są one obsługiwane w kolejności ich nadania.
		\end{enumerate}
		Rysunek \ref{Fig:memory_access} przedstawia przykład komunikacji między modułem \textit{LSU} a pamięcią.
			\begin{samepage}
				\captionof{figure}{Komunikacja \textit{LSU} z pamięcią\label{Fig:memory_access}}
				\nopagebreak
				\begin{center}
					\includegraphics[width=14cm]{./rysunki/memory_access.png}
				\end{center}
			\end{samepage}
	\item \textit{\textit{Register File}} - zawiera trzydzieści jeden lub piętnaście 32-bit rejestrów. Liczba ich jest zależna od rozszerzenia \textit{RV32E}. Rejestr \textit{x0} jest zawsze zerem. Moduł ten posiada dwa porty przeznaczone dla odczytu i jeden dla zapisu. Gdy dany rejestr jest równocześnie zapisywany i odczytywany, zwróci on wartość aktualną a nie zapisywaną.
	\item \textit{Control and Status Registers} - zawiera rejestry kontrolne i statusu.
\end{itemize}
		 
		\subsubsection{Komunikacja rdzenia z magistralą \textit{Wishbone}}
\hspace{5mm}
Instancje \textit{data\_core2wb} i \textit{instr\_core2wb} modułu \textit{ibex\_to\_wb} są odpowiedzialne za komunikację rdzenia z magistralą. Moduł ten posiada dwa porty:
\begin{enumerate}
	\item \textit{core} - modport \textit{slave} pochodzący z interfejsu \textit{ibex\_if}. Dla instancji \textit{data\_core2wb} została przypisana instancja \textit{data\_core}, dla instancja \textit{instr\_core2wb} została przypisana instancja \textit{insftr\_core}.
	\item \textit{wb} - modport \textit{master} pochodzący z interfejsu \textit{wishbone\_if}. Dla instancji \textit{data\_core2wb} została przypisana instancja \textit{data\_wb}. Dla instancji \textit{instr\_core2wb} została przypisana instancja \textit{instr\_wb}.
\end{enumerate}
W module tym zostało wykorzystane przypisanie ciągłe w celu przekazania wartości sygnałów. Listing \ref{Lis:ibex-2-wb} przedstawia te przypisania.\\
\begin{minipage}{\textwidth}
\begin{scriptsize}
\begin{lstlisting}[label=Lis:ibex-2-wb,caption=Przypisanie ciągłe modułu \it ibex\_to\_wb]
	assign core.gnt    = core.req & ~wb.stall;
	assign core.rvalid = wb.ack;
	assign core.err    = wb.err;
	assign core.rdata  = wb.data_s;
	assign wb.stb      = core.req;
	assign wb.addr     = core.addr;
	assign wb.data_m   = core.wdata;
	assign wb.we       = core.we;
	assign wb.sel      = core.we ? core.be : '1;

	always_ff @(posedge wb.clk_i or posedge wb.rst_ni)
		if (!wb.rst_ni)
			cyc <= 1'b0;
		else
		if (core.req)
			cyc <= 1'b1;
		else if (wb.ack || wb.err)
			cyc <= 1'b0;

	assign wb.cyc = core.req | cyc;}
\end{lstlisting}

\end{scriptsize}
\end{minipage}
Dzięki temu zabiegowi, każda zmiana sygnału zostanie przeniesiona na magistralę \textit{Wishbone}.
	\subsection{Wishbone}
	\hspace{5mm}
Magistrala \textit{Wishbone} składa się z następujących komponentów:
\begin{itemize}
\item Instancje interfejsu \textit{wishbone\_if}: \textit{wb\_master} i \textit{wb\_slave},
\item instancji modułu \textit{wishbone\_sharedbus}: \textit{wb\_share\_bus},
\item modułów służących do podłączenia komponentów systemu na czipie do magistrali:
	\begin{itemize}
		\item \textit{wb\_gpio} - moduł łączący GPIO z magistralą,
		\item \textit{wb\_uart} - moduł łączącu UART z magistralą,
		\item \textit{wb\_i2c} - moduł łączący I2C z magistralą,
		\item \textit{wb\_spi\_master} - moduł łączący SPI master z magistralą,
		\item \textit{wb\_spi\_slave} - moduł łączący SPI slave z magistralą,
		\item \textit{wb\_timer} - moduł łączący timer z magistralą,
		\item \textit{wb\_ram} - moduł łączący pamięć RAM z magistralą.
	\end{itemize}
\end{itemize}
Rysunek \ref{Fig:wishbone_ibex} przedstawia porównanie komunikacji magistrali \textit{Wishbone} z komunikacją \textit{LSU} z pamięcią.

			\begin{minipage}{\textwidth}
				\captionof{figure}{Porównanie komunikacji Ibex z \textit{Wishbone}\label{Fig:wishbone_ibex}}
					\includegraphics[width=14cm]{./rysunki/timing.png}
			\end{minipage} 

\subsubsection{Interfejs magistrali \textit{Wishbone}}
Interfejs magistrali posiada dwie instancje:
\begin{itemize}
\item \textit{wb\_master} - tablica interfejsu, wielkość tej tablicy definiowana jest przez parametr \textit{NUM\_MASTER}. Jest ona przeznaczona dla urządzeń typu \textit{master},
\item \textit{wb\_slave} - tablica interfejsu, wielkość tej tablicy definiowana jest przez parametr \textit{NUM\_SLAVE}. Jest ona przeznaczona dla urządzeń typu \textit{slave}.
 \end{itemize}
 W celu zarządzania kierunkami sygnałów, zostały utworzone dwa modporty: \textit{master} i \textit{slave}. Wyprowadzenia oraz ich przeznaczenie zostały opisane w tabeli \ref{Tab:wb_if}.
 \\
 \begin{minipage}{\textwidth}
		 \begin{center}
			\captionof{table}{Sygnały interfejsu \textit{wishbone\_if}\label{Tab:wb_if}}
				\begin{tabular}{|c|c|c|c|}
					\hline
					\multicolumn{2}{|c|}{Kierunek sygnału} & \multirow{2}{*}{Nazwa sygnału} & \multirow{2}{*}{Przeznaczenie}\\
					\cline{1-2}
					Modport master & Modport slave & & \\ 
					\hline
					input & input & clk\_i & sygnał zegarowy \\
					\hline
					input & input & rst\_ni & sygnał resetu \\
					\hline
					output & input & addr & sygnał adresu\\
					\hline
					output & input & data\_m & sygnał danych mastera\\
					\hline
					input & output & data\_s & sygnał danych slave'a\\
					\hline
					output & input & we & zezwolenie zapisu\\
					\hline
					output & input & sel & selekcja bajtu\\
					\hline
					output & input & stb & potwierdzenie nadania danych\\
					\hline
					input & output & ack & potwierdzenie przyjęcia danych\\
					\hline
					output & input & cyc & cykl magistrali\\
					\hline
					input & output & err & sygnał błędu\\
					\hline
					input & output & stall & sygnał zajętości\\
					\hline
				\end{tabular}
		\end{center}
		\end{minipage}
		\subsubsection{Połączenia magistrali \textit{Wishbone}}
		\hspace{5mm}
		W celu komunikacji urządzeń typu \textit{slave} z urządzeniami typu \textit{master} należało przygotować odpowiedni moduł, kontrolujący tę komunikację. Jest on parametryzowany:
		\begin{itemize}
		\item \textit{num\_master = -1} - określa liczbę urządzeń typu \textit{master},
		\item \textit{num\_slave = -1} - określa liczbę urządzeń typu \textit{slave},
		\item \textit{bit [31:0] base\_addr[num\_slave] = '\{-1\}} - tablica adresów początkowych urządzeń typu \textit{slave}. Jej szerokość definiowana jest poprzez parametr \textit{num\_slave}, każde jej pole to liczba całkowita 32bitowa.
		\item \textit{bit [31:0] size[num\_slave] = '\{-1\} } - tablica szerokości adresu pod jakim znajduje się urządzenie typu \textit{slave}. Jej szerokość definiowana jest poprzez parametr \textit{num\_slave}, każde jej pole to liczba całkowita 32bitowa.
		\end{itemize}		 
		Wartość domyślna parametrów to $-1$, ma to uchronić przed złym przypisaniem wartości podczas inicjalizacji tego modułu. Lista portów tego modułu składa się z dwóch modportów:
		\begin{itemize}
			\item \textit{wishbone\_if.slave wb\_master[num\_master]} - port przeznaczony dla odczytu informacji z urządzeń typu \textit{master}. Został użyty modport \textit{slave} w celu zabezpieczenia przed przypadkowym nadpisaniem sygnałów.
			\item \textit{wishbone\_if.master wb\_slave[num\_slave]} - port przeznaczony do odczytu informacji z urządzeń typu \textit{slave}. Został użyty modport \textit{master} w celu zabezpieczenia przed przypadkowym nadpisaniem sygnałów.
		\end{itemize}
		Przykładowa inicjalizacja modułu została pokazana na Listingu \ref{Lis:shared_bus}. Kolejność parametrów podanych do przypisania tablicy \textit{base\_addr} i \textit{size} musi się zgadzać z indeksem przypisanym dla poszczególnego komponentu. \\
		\begin{minipage}{\textwidth}
\begin{scriptsize}
\begin{lstlisting}[label=Lis:shared_bus,caption=Przykładowa inicjalizacja modułu \textit{wishbone\_sharedbus}]
	wishbone_sharedbus
	#(	.num_master      (NUM_MASTER),
		.num_slave      (NUM_SLAVE),
		.base_addr ('{RAM_INSTR_BASE_ADDR,RAM_DATA_BASE_ADDR, GPIO_BASE_ADDR,
		 UART_BASE_ADDR, I2C_BASE_ADDR, SPI_BASE_ADDR, TIMER_BASE_ADDR}),
		.size      ('{RAM_INSTR_SIZE, RAM_DATA_SIZE, GPIO_SIZE, UART_SIZE,
		 I2C_SIZE, SPI_SIZE, TIMER_SIZE}))       
	wb_share_bus(
		.wb_master(wb_master),
		.wb_slave(wb_slave));
\end{lstlisting}
\end{scriptsize}
\end{minipage}
\\
		Dla sygnałów pochodzących z urządzeń zostały utworzone pomocnicze tablice zmiennych tymczasowych. Szerokość tych tablic definiują parametry \textit{num\_master} i \textit{num\_slave}. Zdefiniowane zostały również sygnały wspólne, mające na celu przekazywanie wartości między komponentami.\\
		W pierwszym kroku należy odczytać/przypisać wartości dla danych modportów. Listing \ref{Lis:przypisanie_sharedbus} przedstawia tą operację.\\
				\begin{minipage}{\textwidth}
\begin{scriptsize}
\begin{lstlisting}[label=Lis:przypisanie_sharedbus,caption=Przykładowa inicjalizacja modułu \textit{wishbone\_sharedbus}]
    for (genvar i = 0; i < num_master; i++)
        begin
            assign wb_master_cyc[i] = wb_master[i].cyc;
            .
            .
            .
            assign wb_master[i].ack = wb_master_ack[i];            
         end

        for (genvar i = 0; i < num_slave; i++)
        begin
            assign wb_slave[i].cyc = wb_slave_cyc[i];
            .
            .
            .            
            assign wb_slave_ack[i] = wb_slave[i].ack;            
         end
\end{lstlisting}
\end{scriptsize}
\end{minipage}
Pętla \textit{for} z użyciem zmiennej typu \textit{genvar} pozwala tworzyć bloki generyczne. Dzięki nim i przypisaniu ciągłemu wartości poszczególnych sygnałów zawsze zostaną przypisane gdy nastąpi ich zmiana.\\
Wybór aktywnego urządzenia \textit{slave} jest dokonywany poprzez iterację po tablicy adresów i sprawdzenie poprzez operator \textit{inside} czy adres podany przez \textit{mastera} znajduje się w przestrzeni adresowej urządzenia \textit{slave}. Gdy jest to prawdą, operator zwróci jedynkę logiczną, która jest przypisywana do tablicy \textit{slave\_select} w komórkę odpowiadającej danemu urządzeniu \textit{slave}. Operacja ta została umieszczona w bloku proceduralnym \textit{always\_comb} więc przy każdej zmianie adresu operacja ta jest ponawiana. Listing \ref{Lis:slave_select} przedstawia ten proces.\\
\begin{minipage}{\textwidth}
\begin{scriptsize}
\begin{lstlisting}[label=Lis:slave_select,caption=Wybór urządzenia \textit{slave}]
	always_comb
		for (int i = 0; i < num_slave; i++)
			ss[i] = addr inside {[base_addr[i]:(base_addr[i]+size[i])]};
            
	always_ff @(posedge wb_slave[0].clk_i or posedge wb_slave[0].rst_ni)
		if (!wb_slave[0].rst_ni)
			ss1 <= '0;
		else
		if (cyc && stb)
			ss1 <= ss;
\end{lstlisting}
\end{scriptsize}
\end{minipage}
Informacja o wyborze danego urządzenia jest przekazywana za pomocą nie blokującego przypisania do tablicy \textit{slave\_select\_1} w celu zapewnienia potokowości. Blok proceduralny \textit{always\_comb} zapewnia komunikacje między \textit{masterem} a urządzeniem \textit{slave}. Listing \ref{Lis:comb_comunitation} przedstawia ten zabieg.  \\
\begin{minipage}{\textwidth}
\begin{scriptsize}
\begin{lstlisting}[label=Lis:comb_comunitation,caption=Komunikacja urządzenia \textit{master} z urządzeniem \textit{slave}]
	always_comb begin
		ack    = 1'b0;
		err    = 1'b0;
		stall  = 1'b0;
		data_rd = '0;
		for (int i = 0; i < num_slave; i++) begin
			ack   |= wb_slave_ack[i];
			err   |= wb_slave_err[i];
			stall |= wb_slave_stall[i];
			wb_slave_cyc[i]   = cyc;
			wb_slave_addr[i]   = '0;
			wb_slave_stb[i]   = 1'b0;
			wb_slave_we[i]    = we;
			wb_slave_sel[i]   = '0;
			wb_slave_data_o[i] = '0;
			if (ss[i]) begin
				wb_slave_addr[i]   = addr;
				wb_slave_stb[i]   = cyc & stb;
				wb_slave_sel[i]   = sel;
				wb_slave_data_o[i] = data_wr;
			end
			if (ss1[i])
				data_rd = wb_slave_data_i[i];
		end
	end
\end{lstlisting}
\end{scriptsize}
\end{minipage}
Jeśli urządzenie \textit{slave} zostało wybrane, przekazywane są do niego sygnały z urządzenia \textit{master} w kolejnym cyklu zegarowym dane są przypisywane do urządzenia \textit{master}.\\
Obsługa urządzeń \textit{master} jest analogiczna. Gdy pojawi się sygnał \textit{cyc} informujący o żądaniu mastera następuje zapisanie stanu wysokiego dla sygnału \textit{gnt}, w kolejnym cyklu zegarowym wartość ta jest przekazywana do \textit{gnt\_1} w celu zachowania potokowości. Gdy urządzenie \textit{master} jest gotowe do działania, zapisuje dane do sygnałów wspólnych, te przekazują je urządzeniu \textit{slave}. Potwierdzeniem udanej transmisji jest przekazanie sygnału \textit{ack} potwierdzającego odczyt danych przez peryferia i sygnału \textit{err}, który komunikuje o problemach.\\ Rysunek \ref{Fig:wishbone_timing} przedstawia przebiegi sygnałów tego modułu uzyskanych dzięki symulacji. Po otrzymaniu prawidłowego adresu sygnał \textit{ss} zmienił swój stan na wysoki, w kolejnym cylku zegarowym stan wysoki przyjmuje sygnał \textit{ss1} - co odpowiada opisowi. Pojawienie się jedynki logicznej w sygnale \textit{stb} spowodowało aktywację sygnału \textit{gnt} a z kolejnym cyklem zegarowym wartość ta zostaje przepisana na sygnał \textit{gnt1}. Wysoki stan \textit{ss} spowodował aktywację urządzenie \textit{slave}, można to zauważyć poprzez pojawienie się adresu na linii \textit{wb\_slave\_addr}, dzięki \textit{ss1} dane z linii \textit{wb\_slave\_data\_i[0]} zostały przekazane do \textit{data\_rd}, sygnał \textit{gnt\_1} pozwolił na zapis ich na linii \textit{wb\_master\_data\_o[1]} \\
			\begin{minipage}{\textwidth}
				\captionof{figure}{Przebiegi sygnałów podczas symulacji\label{Fig:wishbone_timing}}
				\begin{center}
					\includegraphics[height=16cm,width=14cm,keepaspectratio]{./rysunki/wishbone_timing.png}
				\end{center}
			\end{minipage} 
	\subsection{Pamięć RAM}
		\subsubsection{Komunikacja pamięci z magistralą \textit{Wishbone}}
			\hspace{5mm}
			W celu poprawnej komunikacji z magistralą należało opisać moduł, którego zadaniem jest poprawna konwersja i przekazywanie sygnałów między magistralą a pamięcią \textit{RAM}. Moduł posiada parametr: \textit{SIZE}, informujący o pojemności tejże pamięci, oraz lokalny parametr:\textit{ADDR\_WIDTH} informujący o szerokości pola adresowego, powstaje on dzięki obliczeniu logarytmu o podstawie dwa z parametru \textit{SIZE}. Parametry te są dalej przekazywane dla modułów opisujących pamięć \textit{RAM}. Listing \ref{Lis:wb_ram} przedstawia komunikacje między pamięcią a magistralą.
			Adres zostaje wybrany poprzez wybranie odpowiedniej części wektora \textit{addr}.  Sygnał \textit{valid} umożliwia zapis/odczyt z pamięci. Jest on aktywny gdy nadejdzie potwierdzenie nadania danych wraz z wysokim stanem sygnału cyklu magistrali. Pozwolenie na zapis danych jest równe koniunkcji sygnałów selekcji oraz powielonemu cztery razy pozwoleniu na zapis pochodzącego od rdzenia. Sygnały zajętości pamięci i błędu zostały podpięte do stanu niskiego ponieważ w modelu pamięci nie istnieje możliwość ich wystąpienia. \\
			\begin{minipage}{\textwidth}
\begin{scriptsize}
\begin{lstlisting}[label=Lis:wb_ram,caption=Komunikacja pamięci z magistralą]
    assign ram_addr = wb.addr[ADDR_WIDTH-1:2];
    assign ram_valid = valid;
    assign ram_we = {4{wb.we}} & wb.sel;
    assign ram_data_i = wb.data_m;
    assign wb.data_s = ram_data_o;
    assign valid = wb.cyc & wb.stb;
    assign wb.stall = 1'b0;
    assign wb.err = 1'b0;
    
    always_ff @(posedge wb.clk_i or posedge wb.rst_ni)
        if (!wb.rst_ni)
            wb.ack <= 1'b0;
        else
            wb.ack <= valid & ~wb.stall;
\end{lstlisting}
\end{scriptsize}
\end{minipage}
		\subsubsection{Pamięć jednoportowa}
			\hspace{5mm}
			Listing \ref{Lis:ram_1p} przedstawia opis modelu pamięci RAM.\\
			\begin{minipage}{\textwidth}
\begin{scriptsize}
\begin{lstlisting}[label=Lis:ram_1p,caption=Model pamięci RAM]
    logic /*sparse*/ [31:0] mem [SIZE];

   always @(posedge clk_i)
     if (valid_i)
       begin
          if (we_i[0]) mem[addr_i][7:0]   <= data_i[7:0];
          if (we_i[1]) mem[addr_i][15:8]  <= data_i[15:8];
          if (we_i[2]) mem[addr_i][23:16] <= data_i[23:16];
          if (we_i[3]) mem[addr_i][31:24] <= data_i[31:24];
       end

   always_ff @(posedge clk_i)
     if (valid_i)
       data_o <= mem[addr_i];

    parameter MEM_FILE = "blink_slow.mem";
    initial begin
      $display("Initializing %s", MEM_FILE);
      $readmemh(MEM_FILE, mem);
    end
\end{lstlisting}
\end{scriptsize}
\end{minipage}
		Komórka pamięci składa się z 32bitów, ilość komórek jest definiowana przez parametr \textit{SIZE}. Argument \textit{/*sparse*/} został użyty w celu optymalizacji symulacji. Parametr \textit{MEM\_FILE} określa ścieżkę do pliku, który zostanie załadowany do pamięci. Podczas wysokiego stanu sygnału \textit{valid\_i} zostaje odczytana komórka pamięci ze wskazanego adresu. Zezwala on również na zapis do komórki pamięci, gdy odpowiedni bit sygnału \textit{we\_i} przejdzie w stan wysoki. Sygnał ten jest 4bitowy, każdy bit odpowiada jednemu bajtu w komórce pamięci. Pamięć jest jednoportowa więc w danej chwili czasu dozwolona jest operacja zapisu lub odczytu danych. By zapobiec kolizji, zaimplementowano dwie pamięci \textit{RAM}, pierwsza odpowiedzialna za przechowywanie instrukcji, druga odpowiedzialna za przechowywanie danych. Pamięć instrukcji została przypisana do zerowej komórki tablicy instancji \textit{wb\_slave} interfejsu \textit{wishbone\_if}, natomiast pamięć danych do pierwszej komórki. Rysunek \ref{Fig:ram_sim} przedstawia przebiegi sygnałów oraz fragment pamięci RAM. Podczas wysokiego stanu sygnału \textit{valid}, pojawiła się informacja o chęci odczytu z danych z komórki o adresie \textit{0020}. Pod tym adresem zapisana jest wartość \textit{0100006F} która w następnym cyklu zegarowym trafia na wyprowadzenie \textit{data\_o}, sytuacja ta powtarza się do momentu pojawienia się stanu niskiego sygnału \textit{valid}. Rysunek \ref{Fig:ram_write} przedstawia sytuacje zapisu do pamięci. Na linii adresowej pojawia się \textit{00}, sygnał \textit{valid\_i} jest w stanie wysokim. Oznacza to, że w następnym cyklu zegarowym do komórki pamięci o adresie \textit{0} zostanie przypisana wartość znajdująca się w \textit{data\_i}. Jak widać na przebiegu sygnałów wartość ta została poprawnie zapisana. Gdy sygnał \textit{valid\_i} jest w stanie niskim, wartość z linii \textit{data\_o} nie powinna zostać przekazana do pamięci. Na przebiegach również została ukazana taka sytuacja, linia adresowa przyjmuje wartość \textit{1D} lecz komórka pamięci o tym adresie nie zostaje zapisana. Listing \ref{Lis:ram_1p_in} i \ref{Lis:ram_1p_data} przedstawiają instancje modułów pamięci.\\
\begin{minipage}{.49\textwidth}
\begin{scriptsize}
\begin{lstlisting}[label=Lis:ram_1p_in,caption=Instancja pamięci instrukcji]
    p1_ram_instr#(
        .SIZE(SIZE),
        .AW(ADDR_WIDTH))
    ram(
        .clk_i(wb.clk_i),
        .addr_i(ram_addr),
        .valid_i(ram_valid),
        .data_i(ram_data_i),
        .data_o(ram_data_o)
    );
\end{lstlisting}
\end{scriptsize}
\end{minipage} \hspace{.02\textwidth}
\begin{minipage}{.49\textwidth}
\begin{scriptsize}
\begin{lstlisting}[label=Lis:ram_1p_data,caption=Instancja pamięci danych]
    p1_ram_data#(
        .SIZE(SIZE),
        .AW(ADDR_WIDTH))
    ram(
        .clk_i(wb.clk_i),
        .addr_i(ram_addr),
        .valid_i(ram_valid),
        .we_i(ram_we),
        .data_i(ram_data_i),
        .data_o(ram_data_o));
\end{lstlisting}
\end{scriptsize}
\end{minipage}\\
					\begin{minipage}[c]{\textwidth}
				\captionof{figure}{Przebiegi sygnałów pamięci \textit{RAM} oraz jej dane podczas odczytu.\label{Fig:ram_sim}}

					\includegraphics[width=\textwidth]{./rysunki/ram_sim.png}
					\includegraphics[width=\textwidth]{./rysunki/pamiec_ram.png}

			\end{minipage} 
					\begin{minipage}[c]{\textwidth}
				\captionof{figure}{Przebiegi sygnałów pamięci \textit{RAM} podczas zapisu.\label{Fig:ram_write}}
					\includegraphics[width=\textwidth]{./rysunki/zapis_ram.png}
			\end{minipage} 
			
		\subsubsection{Pamięć dwuportowa}
			\hspace{5mm}
			Pamięć dwu portowa składa się z dwóch zestawów linii adresowych, danych i sterujących. Pozwala to na jednoczesny dostęp do pamięci dwóm niezależnym procesom do wspólnych danych. Komórka pamięci składa się z 32bitów a ilość komórek jest definiowana przez parametr \textit{SIZE}. Inicjalizacja pamięci odbywa się poprzez podanie ścieżki do pliku w parametrze \textit{MEM\_FILE}. Zapis i odczyt działa w sposób analogiczny jak w przypadku pamięci jednoportowej. Gdy obie linie adresowe wskazują tą samą komórkę, pierwszeństwo ma linia z instrukcji oznaczona literą \textit{b}. Listing \ref{Lis:ram_2p} przedstawia inicjalizację tego modułu. Sygnały \textit{b\_we\_i} i \textit{b\_data\_i} zostały przypisane do zera ponieważ w aktualnej wersji przewiduje jedynie wgrywanie kodu maszynowego poprzez podanie odpowiedniej ścieżki za pomocą parametru \textit{MEM\_FILE}.\\
						\begin{minipage}{\textwidth}
\begin{scriptsize}
\begin{lstlisting}[label=Lis:ram_2p,caption=Inicjalizacja dwuportowej pamięci RAM]
    p2_ram#(
        .SIZE(SIZE),
        .AW(ADDR_WIDTH))
    ram(
        .clk_i(wb_data.clk_i),
        .a_addr_i(a_ram_addr),
        .a_valid_i(a_ram_valid),
        .a_we_i(a_ram_we),
        .a_data_i(a_ram_data_i),
        .a_data_o(a_ram_data_o),
		
        .b_addr_i(b_ram_addr),
        .b_valid_i(b_ram_valid),
        .b_we_i('0),
        .b_data_i('0),
        .b_data_o(b_ram_data_o)    );
\end{lstlisting}
\end{scriptsize}
\end{minipage}

	\subsection{GPIO}
		\subsubsection{Komunikacja z magistralą \textit{Wishbone}}
		\hspace{5mm}	W celu poprawnej komunikacji należało przygotować moduł odpowiedzialny za konwersję i przekazywanie danych między \textit{GPIO} a magistralą. Rolę tę pełni \textit{wb\_gpio}. Moduł ten zawiera instancję \textit{GPIO} oraz sygnały pomocnicze do komunikacji. Listing \ref{Lis:gpio_wb} przedstawia fragment tego modułu.\\
									\begin{minipage}{\textwidth}
\begin{scriptsize}
\begin{lstlisting}[label=Lis:gpio_wb,caption=Komunikacja \textit{GPIO} z magistralą]
   assign valid    = wb.cyc & wb.stb;
   assign select_output   = wb.addr[11:2] == 0;
   assign select_input   = wb.addr[11:2] == 1;
   assign wb.stall = 1'b0;
   assign wb.err   = 1'b0;

   always_ff @(posedge wb.clk_i or posedge wb.rst_ni)
     if (!wb.rst_ni)
       wb.ack <= 1'b0;
     else
       wb.ack <= valid & ~wb.stall;

   assign wb.data_s = {28'h0000000, data_s};   
\end{lstlisting}
\end{scriptsize}
\end{minipage}
		Do linii \textit{data\_s} został przypisany sygnał pochodzący z instancji \textit{GPIO} \textit{data\_s}, jest on 4bitowy więc by w pełni zapełnić przestrzeń zastosowano konkatenację. Sygnały \textit{wb.err} i \textit{wb.stall} zostały przypisane do zera. Projekt sytuacji by te sygnały mogą się pojawić. Wybór kierunku transmisji jest wybierany poprzez ustawienie odpowiedniego bitu w sygnale \textit{wb.addr}. Jeśli wartość tego wektora będzie równa \textit{0}, dane zostaną przekazane do wyjścia, jeśli wartość wektora będzie równa \textit{1}, dane zostaną odczytane z wejść. Sygnał \textit{valid} jest równy koniunkcji sygnałów \textit{wb.cyc} i \textit{wb.stb}. Sygnał \textit{wb.ack} przyjmuje stan wysoki jeden cykl zegarowy po pojawieniu się sygnału \textit{valid}. 
\subsubsection{Moduł \textit{GPIO}}		
	\hspace{5mm}	 Opis modułu \textit{GPIO} został przedstawiony na listingu \ref{Lis:gpio_module}. Podczas resetu wszystkie sygnały są zerowane. Następnie w zależności od wybranego trybu, dane są przekazywane na diody LED lub odczytywane z przełączników znajdujących się na płytce FPGA. Następnie infomracje są przekazywane do sygnału \textit{data\_s}\\
											\begin{minipage}{\textwidth}
\begin{scriptsize}
\begin{lstlisting}[label=Lis:gpio_module,caption=Model \textit{GPIO}]
	always @(posedge clk_i or posedge rst_ni)
		if (!rst_ni)
			led <= '0;
		else
		if (valid && we && sel_led) begin
			led <= data_m[3:0];
			data_s <= led;
		end

	always @(posedge clk_i or posedge rst_ni)
		if (!rst_ni)
			data_output <= '0;
		else
		if (valid && we && sel_but) begin
			data_input <= button;
			data_s <= data_input;
		end
\end{lstlisting}
\end{scriptsize}
\end{minipage}
	\subsection{\textit{UART}}
	\subsubsection{Komunikacja z magistralą \textit{Wishbone}}
		\hspace{5mm} W celu poprawnej komunikacji z magistralą \textit{Wishbone} został stworzony moduł \textit{wb\_uart}. Znajduje się w nim instancja modułu głównego \textit{UART}, oraz sygnały potrzebne do poprawnego połączenia z magistralą. Listing \ref{Lis:uart_wb} przedstawia inicjalizację modułu głównego \textit{UART} i sygnały pomocnicze.	\\	
\begin{minipage}{\textwidth}
\begin{scriptsize}
\begin{lstlisting}[label=Lis:uart_wb,caption=Model \textit{GPIO}]
	uart#(.clk_freq(50000000),
		.baud_rate(19200),
		.data_bits(8),
		.parity_type(0),
		.stop_bits(0)) uart_top (
		.rx_i(uart_rx_i),
		.tx_data_i(wb.data_m[8-1:0]),
		.tx_data_vld_i(valid_i),
		.rst_i(~wb.rst_ni),
		.clk_i(wb.clk_i),
		.we_i(wb.we),
		.rx_data_vld_o(valid_o),
		.rx_data_o(uart_data_rx),
		.rx_parity_err_o(wb.err),
		.tx_o(uart_tx_o),
		.tx_active_o(wb.stall));

	assign valid_i = wb.cyc & wb.stb;
	assign wb.data_s = {24'h000000, uart_data_rx};  
	always_ff @(posedge wb.clk_i or posedge wb.rst_ni)
		if (!wb.rst_ni)
			wb.ack <= 1'b0;
		else
			wb.ack <= valid_o & ~wb.stall;
\end{lstlisting}
\end{scriptsize}
\end{minipage}		
		W celu przypisania wartości sygnału \textit{uart\_data\_rx} do wektora \textit{wb.data\_s} należy użyć konkatenacji z zerami, ponieważ sygnał ten jest 8bitowy. Zera chronią przed zapisałem niechcianych sygnałów. Sygnał \textit{valid\_i} jest równy koniunkcji sygnałów \textit{wb.cyc} i \textit{wb.stb}. Potwierdzenie nadania informacji poprzez transmiter jest uzyskiwane poprzez mnożenie logiczne sygnału \textit{valid\_o} i negacją sygnału \textit{wb.stall}.
	\subsubsection{Moduł główny \textit{UART}}
	W module głównym znajdują się instancje transmitera i odbiornika \textit{UART}.  Poprzez parametryzowanie go można określić następujące cechy:
	\begin{itemize}
		\item \textit{clk\_freq} - określa częstotliwość zegara systemu na czipie,
		\item \textit{baud\_rate} - określa szybkość transmisji, w projekcie jego wartość jest równa 19200bps,
		\item \textit{data\_bits} - określa szerokość wektora danych. W projekcie użyto 8bitowej szerokości
		\item \textit{parity\_type} - określa bit parzystości, przypisanie zera wyłączy go, jedynki ustawienie go jako bit nieparzystości, dwójki ustawienie go jako bit parzysty. W projekcie bit ten jest wyłączony.
		\item \textit{stop\_bits} - ilość bitów stopu, dostępny jest wybór między jednym a dwoma bitami. W projekcie występuje jeden bit stopu.
	\end{itemize}
	\subsubsection{Transmiter \textit{UART}}
	Transmiter został zaimplementowany w oparciu o graf FSM przedstawiony na rysunku \ref{Fig:fsm_uart_tx}\\
				\begin{minipage}[c]{\textwidth}
				\captionof{figure}{Graf \textit{FSM} odbiornika \textit{UART}.\label{Fig:fsm_uart_tx}}
					\includegraphics[width=\textwidth]{./rysunki/uart_tx_fsm.png}
			\end{minipage}
		Stany te zostały przepisane do lokalnych parametrów, za poruszanie się między nimi odpowiadają zmienne: \textit{tx\_STATE} i \textit{tx\_NEXT}. Podczas resetu sygnały są zerowane i zostaje ustawiony stan \textit{tx\_IDLE}. Po jego zwolnieniu wartości zostają przypisywane do poszczególnych sygnałów. Przedstawia to listing \ref{Lis:uart_tx_reset}.\\
\begin{minipage}{\textwidth}
\begin{scriptsize}
\begin{lstlisting}[label=Lis:uart_tx_reset,caption=Transmiter \textit{UART} po resecie]
			tx_STATE <= tx_NEXT;
			clk_div_reg <= clk_div_next;
			tx_out_reg <= tx_out_next;
			tx_data_reg <= tx_data_next;
			index_bit_reg <= index_bit_next;
			stop_bits_remaining <= stop_bits_remaining_next;
\end{lstlisting}
\end{scriptsize}
\end{minipage}
Podczas stanu \textit{tx\_IDLE} zostają przypisane wartości domyślne, dla sygnału \textit{tx} ustawiony jest stan wysoki. Gdy nadejdzie potwierdzenie przesłania danych przez rdzeń, stan zostaje zmieniony na \textit{tx\_START}.\\
Stan \textit{tx\_START} ustawia sygnał \textit{tx} na niski, rozpoczynając w ten sposób transmisje. Następnie do zmiennej \textit{tx\_NEXT} przypisywany jest stan \textit{tx\_DATA}.\\
Stan \textit{tx\_DATA} został przedstawiony na listingu \ref{Lis:uart_tx_data}. Do sygnału \textit{tx} jest przypisywana wartość wybranego bitu wektora \textit{tx\_data\_reg}. Kolejny krok to sprawdzanie czasu bitu, jeśli licznik czasu dojdzie do samego końca, wskaźnik bitu zwiększa swoją wartość w przeciwnym razie zachodzi inkrementacja licznika czasu i zapętlenie stanu. Przepełnienie wskaźnika bitu skutkuje przejściem w kolejny stan \textit{tx\_STOP} lub \textit{tx\_PARITY} jeśli ustawiony jest parametr.\\
\begin{minipage}{\textwidth}
\begin{scriptsize}
\begin{lstlisting}[label=Lis:uart_tx_data,caption=Stan \textit{tx\_DATA}]
tx_DATA: begin
	tx_out_next = tx_data_reg[index_bit_reg];
	if(clk_div_reg < clock_divide[$clog2(clock_divide):0]-1'b1) begin
		clk_div_next = clk_div_reg + 1'b1;
		tx_NEXT = tx_DATA;
	end
	else begin
		clk_div_next = 0;
		if(index_bit_reg < (data_bits-1)) begin
			index_bit_next = index_bit_reg + 1'b1;
			tx_NEXT = tx_DATA;
		end
		else begin
			index_bit_next = 0;
			if(parity_type == 0) begin
				tx_NEXT = tx_STOP;
			end
			else begin
				tx_NEXT = tx_PARITY;
			end
		end
	end
end
\end{lstlisting}
\end{scriptsize}
\end{minipage}
Parzystość zostaje sprawdzana przy pomocy operatorów redukcji \textit{XOR} lub \textit{NXOR} użytych na całym wektorze \textit{tx\_data\_reg}. Po wysłaniu tej informacji, do zmiennej \textit{tx\_NEXT} zostaje przypisany stan \textit{tx\_STOP}.\\
W stanie \textit{tx\_STOP} zostaje wysłana odpowiednia ilość bitów stopu. Po dokonaniu tej operacji, stan wraca do \textit{tx\_IDLE}.
	\subsubsection{Odbiornik \textit{UART}}
	Odbiornik został zaimplementowany w oparciu o graf FSM przedstawiony na rysunku \ref{Fig:fsm_uart_rec} \\
			\begin{minipage}[c]{\textwidth}
				\captionof{figure}{Graf \textit{FSM} odbiornika \textit{UART}.\label{Fig:fsm_uart_rec}}
					\includegraphics[width=\textwidth]{./rysunki/uart_fsm_rec.png}
			\end{minipage} 
			Stany te zostały zdefiniowane jako lokalne parametry, za poruszanie się między nimi odpowiedzialne są dwie zmienne: \textit{rx\_STATE} oraz \textit{rx\_NEXT}. Podczas resetu sygnały są zerowane, do zmiennej \textit{rx\_STATE} zostaje przypisany stan \textit{rx\_IDLE}. Po jego zwolnieniu następuje przypisanie nie blokujące, które ma na celu przypisania wartości w następnym cyklu zegarowym. W ten sposób aktualizacja stanu nastąpi zawsze na początku cyklu. Listing \ref{Lis:uart_po_res} pokazuje wszystkie przypisania. Całość mieści się w bloku proceduralnym \textit{always\_ff}.\\
\begin{minipage}{\textwidth}
\begin{scriptsize}
\begin{lstlisting}[label=Lis:uart_po_res,caption=Odbiornik \textit{UART} po resecie]
			rx_STATE <= rx_NEXT;
			clk_div_reg <= clk_div_next;
			rx_data_reg <= rx_data_next;
			index_bit_reg <= index_bit_next;
			rx_data_vld <= rx_data_vld_next;
			rx_parity_err <= parity_err_next;
			stop_bits_remaining <= stop_bits_remaining_next;
\end{lstlisting}
\end{scriptsize}
\end{minipage}	
Pierwszą fazą która występuje po resecie jest: \textit{rx\_IDLE}. Podczas niej blok czeka, aż na linii \textit{rx} pojawi się zero logiczne, oznaczające początek transmisji. Jeśli ten warunek zostanie spełniony do zmiennej \textit{rx\_NEXT} zostaje przypisana faza \textit{rx\_START}. Jeśli na linii \textit{rx} wciąż pozostaje stan wysoki do \textit{rx\_NEXT} przypisany zostanie \textit{rx\_IDLE}. Podczas tej fazy zostają ustawione wartości początkowe dla sygnałów.\\
W fazie \textit{rx\_START} następuje ponowne sprawdzenie stanu sygnału \textit{rx}, sprawdzenie te następuje w połowie trwania bitu. Jeśli pozostał w stanie niskim nastąpi przypisanie do \textit{rx\_NEXT} kolejnego stanu, którym jest \textit{rx\_DATA}. Jeśli sygnał powrócił do stanu wysokiego, stan wraca do \textit{rx\_IDLE}.\\
Faza \textit{rx\_DATA} została przedstawiona na listingu \ref{Lis:rx_data}. Pierwszym krokiem w tym stanie, jest sprawdzanie w jakim czasie trwania bitu znajduje się sygnał. W warunku sprawdzającym ograniczono wielkość wektora \textit{clock\_divide} na niezbędnej ilości bitów w celu optymalizacji projektu. Gdy licznik przyjmie wartość  równą końcu czasu bitu, następuje jego wyzerowanie i przypisanie wartości sygnały \textit{rx} do wektora \textit{rx\_data\_next}. Następnie jest sprawdzana ilość odebranych bitów, jeśli zostanie ona przekroczona, następuje kolejny stan \textit{rx\_STOP} lub \textit{rx\_PARITY} w zależności od ustawień parametru odpowiedzialnego za parzystość bitu. W przeciwnym razie, wartość indeksu wektora zostaje zwiększona i stan się zapętla.\\			\begin{minipage}{\textwidth}
\begin{scriptsize}
\begin{lstlisting}[label=Lis:rx_data,caption=Stan \textit{rx\_DATA}]
rx_DATA: begin
	if(clk_div_reg < clock_divide[$clog2(clock_divide):0]-1'b1) begin
		clk_div_next = clk_div_reg + 1'b1;
		rx_NEXT = rx_DATA;
	end
	else begin
		clk_div_next = 0;
		rx_data_next[index_bit_reg] = rx;
		if(index_bit_reg < (data_bits-1)) begin
			index_bit_next = index_bit_reg + 1'b1;
			rx_NEXT = rx_DATA;
		end
		else begin
			index_bit_next = 0;
			if(parity_type == 0) begin
				rx_NEXT = rx_STOP;
			end
			else begin
				rx_NEXT = rx_PARITY;
			end
		end
	end
end
\end{lstlisting}
\end{scriptsize}
\end{minipage}	
Parzystość zostaje sprawdzana za pomocą operatorów redukcji \textit{XOR} i \textit{NXOR} zastosowanych na całym wektorze \textit{rx\_data\_reg}. \\
W fazie \textit{rx\_STOP} blok czeka na pojawienie się określonej ilości bitów stopu. Gdy warunek ten zostanie spełniony stan wraca do \textit{rx\_IDLE} oraz ustawia logiczną jedynkę dla sygnału potwierdzającego odbiór transmisji.

	\subsection{SPI}
		\subsubsection{Komunikacja z magistralą \textit{Wishbone}}
		\hspace{5mm} W celu poprawnej komunikacji z magistralą \textit{Wishbone} , należało stworzyć moduły \textit{wb\_spi\_master} i \textit{wb\_spi\_slave}. Moduły te zawierają instancje \textit{SPI}, oraz pomocnicze sygnały dla poprawnego przekazywania informacji. Listingi \ref{Lis:spi_master} i \ref{Lis:spi_slave} przedstawiają instancję tych modułów. Parametr \textit{SPI\_SLAVE} określa szerokość wektora wyboru urządzeń \textit{slave}. Sygnał \textit{valid} dla modułu \textit{spi\_slave} jest równy koniunkcji sygnałów \textit{wb.cyc} i \textit{wb.stb}. Sygnał wyjściowy powstaje poprzez konkatenację wektora \textit{data\_out} z zerami. Sygnały błędu i zajętości zostały przypisane do zera, ponieważ projekt nie przewiduje ich wystąpienia.\\
		\begin{minipage}{.49\textwidth}
\begin{scriptsize}
\begin{lstlisting}[label=Lis:spi_master,caption=Instancja pamięci instrukcji]
    spi_master#(SPI_SLAVE) spi_master(
    .clk_i(wb.clk_i),
    .rst_i(~wb.rst_ni),
    .cyc_i(wb.cyc),
    .stb_i(wb.stb),
    .adr_i(wb.addr[4:2]),
    .we_i(wb.we),
    .dat_i(wb.data_m[8-1:0]),
    .dat_o(data_out),
    .ack_o(wb.ack),
    .inta_o(irq_o),
    .sck_o(sck_o),
    .cs_o(cs_o),
    .mosi_o(mosi_o),
    .miso_i(miso_i));
\end{lstlisting}
\end{scriptsize}
\end{minipage} \hspace{.02\textwidth}
\begin{minipage}{.49\textwidth}
\begin{scriptsize}
\begin{lstlisting}[label=Lis:spi_slave,caption=Instancja pamięci danych]
    spi_slave spi_slave(
    .clk_i(wb.clk_i),
    .rst_i(~wb.rst_ni),
    .tx_dv_i(valid),
    .tx_byte_i(wb.data_m[8-1:0]),
    .rx_byte_o(data_out),
    .rx_dv_o(wb.ack),
    .spi_clk_i(sck_i),
    .cs_i(cs_i),
    .mosi_i(mosi_i),
    .miso_o(miso_o));
\end{lstlisting}
\end{scriptsize}
\end{minipage}\\
		\subsubsection{\textit{SPI Master}}
		\hspace{5mm} Moduł \textit{SPI Master} został zaimplementowany na podstawie schematu blokowego przedstawionego na rysunku \ref{Fig:spi_master_block}.\\
					\begin{minipage}[c]{\textwidth}
				\captionof{figure}{Graf \textit{FSM} odbiornika \textit{UART}.\label{Fig:spi_master_block}}
					\includegraphics[width=\textwidth,height=9.5cm]{./rysunki/spi_arch.png}
			\end{minipage} 
		Rejestry \textit{SPCR}, \textit{SPER}. \textit{SPSR} i \textit{SPDR} znajdują się pod odpowiednim adresem, tabela \ref{Tab:spi_reg} przedstawia je.
		\\
 \begin{minipage}{\textwidth}
		 \begin{center}
			\captionof{table}{Lista rejestrów \textit{SPI}\label{Tab:spi_reg}}
				\begin{tabular}{|c|c|c|c|c|}
					\hline
					Nazwa & adres & ilość bitów & dostęp & opis \\ 
					\hline
					SPCR & 0x00 & 8 & zapis/odczyt & rejestr sterujący \\
					\hline
					SPSR & 0x01 & 8 &zapis/odczyt & rejestr statusu \\
					\hline
					SPDR & 0x02 & 8 &zapis/odczyt & rejestr danych\\
					\hline
					SPER & 0x03 & 8 &zapis/odczyt & rejestr rozszerzeń\\
					\hline
					CS & 0x04 & [SPI\_SLAVE-1:0] & zapis/odczyt & rejestr wyboru \textit{slave} \\
					\hline
					
				\end{tabular}
		\end{center}
		\end{minipage}	
\\\\
Zawartość rejestru \textit{SPCR} jest przedstawiona na rysunku \ref{Fig:spcr}. Dostęp do wszystkich jego bitów jest zapis/odczyt.\\
\begin{minipage}[c]{\textwidth}
				\captionof{figure}{Rejestr \textit{SPCR}.\label{Fig:spcr}}
					\includegraphics[width=\textwidth]{./rysunki/spcr.png}
			\end{minipage} 
			\begin{itemize}
				\item Bit 7 \textit{SPIE} - Uaktywnienie przerwań SPI - gdy bit ten jest jedynką logiczną, następuje włączenie przerwań, działa tylko gdy bit \textit{SPIF} w rejestrze \textit{SPER} również jest ustawiony na jedynkę logiczną
				\item Bit 6 \textit{SPE} - Włączenie SPI - gdy bit ten jest jedynką logiczną, następuje włączenie interfejsu SPI
				\item Bit 4 \textit{MSTR} - Selekcja trybu \textit{master} - gdy bit ten jest jedynką logiczną, następuje przełączenie urządzenia w tryb \textit{master}, w projekcie bit ten zawsze jest jedynką logiczną
				\item Bit 3 \textit{CPOL} - Polaryzacja zegara, gdy bit ten jest jedynką logiczną, sygnał \textit{SCK} ma wartość wysoką w stanie nieaktywnym. Gdy bit ten jest zerem logicznym, sygnał \textit{SCK} ma wartość niską w stanie nieaktywnym
				\item Bit 2 \textit{CPHA} - Faza zegara, gdy bit ten jest jedynką logiczną na zboczu narastającym następuje przygotowanie, na zboczu opadającym następuje próbkowanie. Gdy bit ten jest zerem logicznym, zbocze narastające powoduje fazę próbkowania a opadające fazę przygotowania
				\item Bit 0 i 1 \textit{SPR} - Wybór częstotliwości zegarowej - bity te kontrolują częstotliwość sygnału \textit{SCK}. Zależność ta, została pokazana w tabeli \ref{Tab:espr}.
			\end{itemize}
Zawartość rejestru \textit{SPSR} została przedstawiona na rysunku \ref{Fig:spsr}.\\
\begin{minipage}[c]{\textwidth}
				\captionof{figure}{Rejestr \textit{SPSR}.\label{Fig:spsr}}
					\includegraphics[width=\textwidth]{./rysunki/spsr.png}
			\end{minipage} 
			\begin{itemize}
				\item Bit 7 \textit{SPIF} - Znacznik przerwania SPI - po zakończeniu transferu, bitowi jest przypisywana jedynka logiczna, jeśli bit \textit{SPIE} również jest jedynką logiczną, generowany jest sygnał przerwania.
				\item Bit 6 \textit{WCOL} - Znacznik kolizji zapisu - bitowi jest przypisywana jedynka logiczna jeśli bit \textit{WFFULL} jest w stanie wysokim i odbywa się zapis do rejestru danych.
				\item Bit 3 \textit{WFFULL} - Znacznik zapełnienia \textit{FIFO} przeznaczonego do zapisu - bitowi jest przypisywana jedynka logiczna, gdy \textit{FIFO} zostanie zapełnione,
				\item Bit 2 \textit{WFEMPTY} - Znacznik pustego \textit{FIFO} przeznaczonego do zapisu - bitowi jest przypisywana jedynka logiczna, gdy \textit{FIFO} jest puste
				\item Bit 1 \textit{WEFULL} - Znacznik zapełnienia \textit{FIFO} przeznaczonego dla odczytu - bitowi jest przypisywana jedynka logiczny, gdy \textit{FIFO} zostanie zapełnione
				\item Bit 0 \textit{WEEMPTY} - Znacznik pustego \textit{FIFO} przeznaczonego dla odczytu - bitowi jest przypisywana jedynka logiczna, gdy \textit{FIFO} jest puste
			\end{itemize}
W rejestrze \textit{SPDR} znajdują się dane, przechowywane one są w dwóch \textit{FIFO}, zapisu i odczytu. Ustawienie zera logicznego na bicie \textit{SPE} powoduje wyczyszczenie \textit{FIFO}. \\
Zawartość rejestru \textit{SPER} jest przedstawiona na rysunku \ref{Fig:sper}.\\
\begin{minipage}[c]{\textwidth}
				\captionof{figure}{Rejestr \textit{SPER}.\label{Fig:sper}}
					\includegraphics[width=\textwidth]{./rysunki/sper.png}
\end{minipage}
\begin{itemize}
	\item Bit 6 i 7 \textit{ICNT} - Licznik przerwań - określa potrzebną ilość zakończonych cykli transferowych po których bitowi \textit{SPIF} zostanie przypisana jedynka logiczna. Tabela \ref{Tab:icnt} przedstawia te zależności.
			\\
 \begin{minipage}{\textwidth}
		 \begin{center}
			\captionof{table}{Lista rejestrów \textit{SPI}\label{Tab:icnt}}
				\begin{tabular}{|c|c|}
					\hline
					ICNT & Opis \\ 
					\hline
					2'b00 & \textit{SPIF} jest ustawiany po każdym zakończonym cyklu transferu \\
					\hline
					2'b01 & \textit{SPIF} jest ustawiany po dwóch zakończonych cyklach transferu \\
				\hline
					2'b10 & \textit{SPIF} jest ustawiany po trzech zakończonych cyklach transferu \\
					\hline
					2'b11 & \textit{SPIF} jest ustawiany po czterech zakończonych cyklach transferu \\
					\hline
				\end{tabular}
		\end{center}
		\end{minipage}	
	\item Bit 0 i 1 \textit{ESPR} - Rozszerzony wybór częstotliwości czasu - dodaje dodatkowe dwa bity pozwalające ustalić częstotliwość \textit{SCK}. Tabela \ref{Tab:espr} przedstawia te zależności.
				\\
 \begin{minipage}{\textwidth}
		 \begin{center}
			\captionof{table}{Dzielnik zegara\label{Tab:espr}}
				\begin{tabular}{|c|c|c|}
					\hline
					ESPR & SPR & Dzielnik zegara \\ 
					\hline
					2'b00 & 2'b00 & 2\\
					\hline
					2'b00 & 2'b01 & 4\\
					\hline
					2'b00 & 2'b10 & 16\\
					\hline
					2'b00 & 2'b11 & 32\\
					\hline
					2'b01 & 2'b00 & 8\\
					\hline
					2'b01 & 2'b01 & 64\\
					\hline
					2'b01 & 2'b10 & 128\\
					\hline
					2'b01 & 2'b11 & 256\\
					\hline
					2'b10 & 2'b00 & 512\\
					\hline
					2'b10 & 2'b01 & 1024\\
					\hline
					2'b10 & 2'b10 & 2048\\
					\hline
					2'b10 & 2'b11 & 4096\\
					\hline
				\end{tabular}
		\end{center}
		\end{minipage}
\end{itemize} 
Rejestr \textit{CS} to rejestr wybory urządzeń typu \textit{slave}. \\
Graf przedstawiony na rysunku \ref{Fig:spi_fsm} przedstawia maszynę stanów odpowiedzialną za transfer informacji. \\

					\begin{minipage}[c]{\textwidth}
				\captionof{figure}{Graf \textit{FSM} \textit{SPI master}.\label{Fig:spi_fsm}}
					\includegraphics[width=\textwidth,height=5.5cm]{./rysunki/fsm_spi.png}
			\end{minipage} 
			 Fazą domyślna jest \textit{IDLE\_STATE}. Jej przebieg został przedstawiony na listingu \ref{Lis:spi_idle}.
			 \begin{minipage}{\textwidth}
\begin{scriptsize}
\begin{lstlisting}[label=Lis:spi_idle,caption=Faza \textit{IDLE\_STATE}]
IDLE_STATE:begin 
	bcnt  <= 3'h7;   
	treg  <= wfdout; 
	sck_o <= cpol;   

	if (~wfempty) begin
		wfre  <= 1'b1;
		state <= CLOCK_PH2;
		if (cpha) sck_o <= ~sck_o;
	end
end
\end{lstlisting}
\end{scriptsize}
\end{minipage}	
Ustawiany jest pomocniczy licznik przesłanych bitów \textit{bcnt}, przypisywany bajt danych do wektora \textit{treg} pochodzących z \textit{FIFO} oraz ustawiana wartość początkowa \textit{sck\_o}. Jeśli \textit{FIFO} nie było puste rozpoczyna się transmisja. Sygnał \textit{wfre} zezwala na odczyt informacji z \textit{FIFO}, stan przechodzi do następnej fazy \textit{CLOCK\_PH2} oraz ustawiana jest faza zegara. \\
W stanie \textit{CLOCK\_PH2} sygnał \textit{sck\_o} zostaje zanegowany i następuje kolejny stan \textit{CLOCK\_PH1}. \\
 Stan \textit{CLOCK\_PH1} odpowiedzialny jest za aktualizację wektora \textit{treg}. Jej przebieg jest przedstawiony na listingu \ref{Lis:spi_clock1}.\\
 			 \begin{minipage}{\textwidth}
\begin{scriptsize}
\begin{lstlisting}[label=Lis:spi_clock1,caption=Faza \textit{CLOCK\_PH1}]
CLOCK_PH1:
	if (ena) begin
		treg <= {treg[6:0], miso_i};
		bcnt <= bcnt -3'h1;

		if (~|bcnt) begin
			state <= IDLE_STATE;
			sck_o <= cpol;
			rfwe  <= 1'b1;
		end else begin
			state <= CLOCK_PH2;
			sck_o <= ~sck_o;
		end
	end
\end{lstlisting}
\end{scriptsize}
\end{minipage}
		\subsubsection{slave}
		
		\hspace{5mm}
			\\opis spi slave

	\subsection{I2C}
		\subsubsection{Komunikacja z magistralą \textit{Wishbone}}
		\subsubsection{master}
		\hspace{5mm}
			\\opis i2c master
		\subsubsection{slave}
		\hspace{5mm}
			\\opis i2c slave

	\subsection{Timer}
	\hspace{5mm}
		\\opis timera


\newpage
\section{Weryfikacja}

	\subsection{RISCV DV}
		\subsubsection{riscv arithmetic basic test}
		\hspace{5mm}
			\\krotko o tym tescie i wynik z simstatus jak rowniez fragment logu komparacji z spike/ovpsim
			
		\subsubsection{riscv rand instr test}
		\hspace{5mm}
			\\krotko o tym tescie i wynik z simstatus jak rowniez fragment logu komparacji z spike/ovpsim
			
		\subsubsection{riscv illegal instr test}
		\hspace{5mm}
			\\krotko o tym tescie i wynik z simstatus jak rowniez fragment logu komparacji z spike/ovpsim

\subsection{ibex core}

\subsection{pamiec ram}

\subsection{gpio}

\subsection{uart}

\subsection{spi}

\subsection{i2c}

\newpage
\section{Benchmarki}
\hspace{5mm}
	\\ pamiec 1p ram vs 2p ram

\newpage
\section{Uruchomienie przykładowego programu}
\newpage
\section{Podsumowanie i wnioski}
	\subsection{dalszy rozwoj}
	\hspace{5mm}
		\\text

\newpage

\section{Bibliografia}

\begin{thebibliography}{10}

	\bibitem{open_source} Karl Michael Popp. \textit{Best Practices for commercial use of open source software}. Books On Demand  2015.
	
	\bibitem{isa_site} https://riscv.org/specifications/ [dostęp 10 sierpień 2020]
	
	\bibitem{isa_book} Andrew Waterman, Krste Asanović. \textit{The RISC-V Instruction Set Manual, Volume I: Base User-Level ISA version 2.2}. University of California, Berkeley. EECS-2016-118. Retrieved 7 May 2017.
	
	\bibitem{ram_book} Kung Linliu. \textit{DRAM-Dynamic Random Access Memory: The memory of computer, smart phone and notebook PC}. Independently Published 2018.
	
	\bibitem{spi_book} https://www.nxp.com/files-static/microcontrollers/doc/ref\_manual/S12SPIV4.pdf [dostęp 10 sierpień 2020]
	
	\bibitem{i2c_book} 	Dominique Paret, Carl Fenger. \textit{The I2C Bus: From Theory to Practice}. Wiley 1997 
	
	\bibitem{uart_book} Adam Osborne. \textit{An Introduction to Microcomputers Volume 1: Basic Concepts}. McGraw-Hill; 2nd edition 1980.
	
	\bibitem{gpio_doc} https://bit.ly/2DJ1Y5F [dostęp 10 sierpień 2020]
	
	\bibitem{wishbone_b4} http://cdn.opencores.org/downloads/wbspec\_b4.pdf [dostęp 10 sierpień 2020]
	
	\bibitem{wishbone_tutorial} http://zipcpu.com/zipcpu/2017/11/07/wb-formal.html [dostęp 10 sierpień 2020]
	
	\bibitem{ibex_doc} https://ibex-core.readthedocs.io/en/latest/index.html [dostęp 10 sierpień 2020]
	
	\bibitem{google_opentitan} https://tcrn.ch/2PIjSrN [dostęp 10 sierpień 2020]

	\bibitem{toolchain} https://github.com/riscv/riscv-gnu-toolchain [dostęp 10 sierpień 2020]
	
	\bibitem{google_dv} https://bit.ly/33Vh8zI [dostęp 10 sierpień 2020]
	
	\bibitem{nexys} \url{https://dl.btc.pl/kamami\_wa/digilent\_nexys4-ddr\_1.pdf} [dostęp 10 sierpień 2020]
	
	\bibitem{SV} \url{https://standards.ieee.org/standard/1800-2017.html} [dostęp 10 sierpień 2020]

\end{thebibliography}

\end{document}

